# 根据前序中序还原二叉树

中序遍历（中根次序遍历）：左根右 DBEAFCG

后序遍历（后根次序遍历）：左右根 DEBFGCA

1. 由后续遍历找到根节点 A
2. 根据中序遍历中的根节点位置,确定左子树和右子树

```js
const inOrder = ["D", "B", "E", "A", "F", "C", "G"];
const nextOrder = ["D", "E", "B", "F", "G", "C", "A"];

function Node(val) {
  this.val = val;
  this.left = null;
  this.right = null;
}

function revert(inOrder, nextOrder) {
  // 1. 根据后序遍历找到根节点
  if (
    inOrder === null ||
    nextOrder === null ||
    inOrder.length === 0 ||
    nextOrder.length === 0
  ) {
    return;
  }
  const rootVal = nextOrder[nextOrder.length - 1];
  const ROOT = new Node(rootVal);
  // 2. 根据中序遍历中的根节点位置,确定左子树和右子树
  const rootIndex = inOrder.indexOf(rootVal);
  const inOrder_leftChildTree = inOrder.slice(0, rootIndex);
  const inOrder_rightChildTree = inOrder.slice(rootIndex + 1);
  const nextOrder_leftChildTree = nextOrder.slice(0, rootIndex);
  const nextOrder_rightChildTree = nextOrder.slice(
    rootIndex,
    nextOrder.length - 1
  );

  ROOT.left = revert(inOrder_leftChildTree, nextOrder_leftChildTree);
  ROOT.right = revert(inOrder_rightChildTree, nextOrder_rightChildTree);
  return ROOT;
}

const root = revert(inOrder, nextOrder);
console.log(root);

// Node {
//     val: 'A',
//     left: Node {
//       val: 'B',
//       left: Node { val: 'D', left: undefined, right: undefined },
//       right: Node { val: 'E', left: undefined, right: undefined }
//     },
//     right: Node {
//       val: 'C',
//       left: Node { val: 'F', left: undefined, right: undefined },
//       right: Node { val: 'G', left: undefined, right: undefined }
//     }
//   }
```

