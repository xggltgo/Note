# State Hook

## 基础用法

State Hook 是一个函数（useState），用于在函数组件中维护状态

- useState接收一个参数，即状态的默认值
- useState返回一个数组，该数组由两项组成
  - 第一项：状态的值
  - 第二项：改变状态的函数

```jsx
import { useState } from 'react';

export default function App() {
  const [count, setCount] = useState(0);
  return <div className="app-container">
    <h1>{count}</h1>
    <button onClick={() => setCount(count + 1)}>Increment</button>
    <button onClick={() => setCount(count - 1)}>Decrement</button>
  </div>;
}
```

## 实现原理

> 函数组件的组件节点中维护了一张**有序**（useState在函数组件中被调用的顺序）的状态表格（状态数组）。
>
> 在每次运行函数组件的过程中，useState运行时会优先与状态表格（状态数组）进行比对，然后做不同的处理。
>
> 第n次调用useState  ===> 检查状态数组中是否存在下标n
>
> 不存在：
>
> - 使用useState的默认值创建一个状态
> - 将该状态加入到状态数组中，下标对应为n
>
> 存在：
>
> - 直接返回状态数组下标n处记录的状态值

代码示例：

| 索引 | 值   |
| ---- | ---- |
| 0    | 0    |
| 1    | true |

```jsx
import { useState } from 'react';

export default function App() {
  const [count, setCount] = useState(0);
  const [visible, setVisible] = useState(true);
  return (
    <div className="app-container">
      <h1
        style={{
          visibility: visible ? 'visible' : 'hidden',
        }}
      >
        {count}
      </h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setVisible(!visible)}>Toggle visibility</button>
    </div>
  );
}
```



## 进阶细节

1. useState推荐书写到函数体的起始位置，便于阅读

2. useState严禁出现在代码块（判断、循环）中，与实现原理相关，防止**按序**取值时造成混乱

3. useState返回的函数（数组的第二项），引用不变（节约内存空间）

4. 使用改变状态的函数改变数据，若数据和之前的数据完全相等（使用Object.is比较），不会导致重新渲染，以达到优化效率的目的。

5. **使用改变状态的函数改变数据，传入的值不会和原来的数据进行合并，而是直接替换**。

6. 如果要实现强制刷新组件
   1. 类组件：使用forceUpdate函数 `this.forceUpdate()`  (强制刷新不会运行`shouldComponentUpdate`生命周期钩子函数)
   
      ```jsx
      import React, { Component } from 'react';
      
      export default class App extends Component {
        render() {
          console.log('App render');
          return (
            <div
              onClick={() => {
                this.forceUpdate();
              }}
            >
              App
            </div>
          );
        }
      }
      ```
   
   2. 函数组件：使用一个空对象的useState
   
       ```js
       import React, { useState } from 'react';
       
       export default function App() {
         console.log('App render');
         const [, forceUpdate] = useState({});
         return (
           <button
             onClick={() => {
               forceUpdate({});
             }}
           >
             强制刷新
           </button>
         );
       }
       ```
   
7. 如果某些状态之间没有必然的联系，应该分化为不同的状态，而不要合并成一个对象，以达到横切关注点的目的

8. **和类组件的状态一样，函数组件中改变状态可能是异步的（在DOM事件中），多个状态变化会合并以提高效率，此时，不能信任之前的状态，而应该使用回调函数的方式改变状态。如果状态变化要使用到之前的状态，尽量传递函数**。