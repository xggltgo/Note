# 迭代器和可迭代协议

> 解决副作用的 redux 中间件
> redux-thunk：需要改动action，可接收action是一个函数
> redux-promise：需要改动action，可接收action是一个promise对象，或action的payload是一个promise对象
> 以上两个中间件，会导致action或action创建函数不再纯净。
> redux-saga将解决这样的问题，它不仅可以保持action、action创建函数、reducer的纯净，而且可以用模块化的方式解决副作用，并且功能非常强大。
> redux-saga是建立在ES6的生成器基础上的，要熟练的使用saga，必须理解生成器。
> 要理解生成器，必须先理解迭代器和可迭代协议。

## 迭代

类似于遍历

遍历：有多个数据组成的集合数据结构（map、set、array等其他类数组），需要从该结构中依次取出数据进行某种处理。

迭代：按照某种逻辑，依次取出下一个数据进行处理。

## 迭代器 iterator

JS语言规定，如果一个对象具有next方法，并且next方法满足一定的约束，则该对象是一个迭代器（iterator）。

next方法的约束：该方法必须返回一个对象，该对象至少具有两个属性：

- value：any类型，下一个数据的值，如果done属性为true，通常，会将value设置为undefined
- done：bool类型，是否已经迭代完成

通过迭代器的next方法，可以依次取出数据，并可以根据返回的done属性，判定是否迭代结束。

```js
// 1.实现一个可迭代的无限的斐波那契数列 1 1 2 3 5 8 13 21
const iterator = {
  first: 1,
  second: 1,
  third: 2,
  next() {
    const obj = {
      value: this.first,
      done: false,
    };
    this.first = this.second;
    this.second = this.third;
    this.third = this.first + this.second;
    return obj;
  },
};

//2.遍历一个迭代器至不能迭代为止
const iterator = {
  i: 1,
  total: 3,
  next() {
    return {
      value: this.i > this.total ? undefined : this.i,
      done: this.i++ > this.total,
    };
  },
};

let next = iterator.next();
while (!next.done) {
  console.log(next);
  next = iterator.next();
}
```

### 迭代器创建函数 iterator creator

它是指一个函数，调用该函数后，返回一个迭代器，则该函数称之为迭代器创建函数，可以简称为迭代器函数。

```js
// 3.迭代器创建函数(该函数返回一个迭代器)
//一个可用于迭代数组的迭代器创建函数
const numbers = [1, 3, 7, 8, 24];
function iteratorForArray(arr) {
  let index = 0;
  return {
    next() {
      return {
        value: arr[index],
        done: index++ >= arr.length,
      };
    },
  };
}

const iterator = iteratorForArray(numbers);

```




## 可迭代协议

ES6中出现了for-of循环，该循环就是用于迭代某个对象的，因此，for-of循环要求对象必须是可迭代的（对象必须满足可迭代协议）

可迭代协议是用于约束一个对象的，如果一个对象满足下面的规范，则该对象满足可迭代协议，也称之为该对象是可以被迭代的。

可迭代协议的约束如下：

1. 对象必须有一个知名符号属性（Symbol.iterator）
2. 该属性必须是一个无参的迭代器创建函数

## for-of循环的原理

调用对象的[Symbol.iterator]方法，得到一个迭代器。不断调用next方法，只要返回的done为false，则将返回的value传递给变量，然后进入循环体执行一次。

```js
const obj = {
  [Symbol.iterator]() { //此处可以看出，该对象满足可迭代协议
    let i = 1,
      total = 3;
    return {
      next() {
        return {
          value: i > total ? undefined : i,
          done: i++ > total,
        };
      },
    };
  },
};

for (const item of obj) {
  console.log(item); // 1 2 3
}
```

