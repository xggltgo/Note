# redux-promise

*redux-promise中间件与redux-thunk中间件类似，都是用于处理副作用，并且二者处理副作用的位置都是在action中*



**redux-promise中间件 处理副作用的方式：**

1. 返回一个Primise,该Promise的resolve的结果会被当做action分发dispatch，也就是说，通过resolve可以dispatch分发action
2. 返回一个平面对象，该对象的payload属性为Promise，该Promise的resolve的结果会作为payload的真实值，更新payload值之后，然后dispatch分发该payload所在的action

- 前提：action是一个满足Flux标准的action
  - action是一个plain-object
  - action.type必须是一个字符串
  - action属性 必须是规范属性中的一个['type','payload','error','meta']

## 使用 redux-promise

**store/index.js**

> 导入redux-promise中间件并应用即可

```js
import { legacy_createStore as createStore, applyMiddleware } from 'redux';
import reducer from './reducer';
import logger from 'redux-logger';
import promiseMiddleware  from '../redux-promise';

export default createStore(reducer, applyMiddleware(promiseMiddleware, logger));
```

**store/action/serachResult.js**

```js
import { getMoviesByPage } from '../../../api/movie';

export const actionTypes = {
  setMovieInfo: 'setMovieInfo',
  setIsLoading: Symbol('setIsLoading'),
};

export function createSetMovieInfoAction(movieList, movieTotal) {
  return {
    type: actionTypes.setMovieInfo,
    payload: {
      movieList,
      movieTotal,
    },
  };
}

export function createSetIsLoadingAction(isLoading) {
  return {
    type: actionTypes.setIsLoading,
    payload: isLoading,
  };
}


//redux-promise中间件 处理副作用

//方式1：返回一个Primise,该Promise的resolve的结果会被当做action分发dispatch
// 也就是说，通过resolve可以dispatch分发action

//①
// export function fetchMovieInfo() {
//   return new Promise((resolve, reject) => {
//     resolve(
//       createSetMovieInfoAction(
//         [
//           { name: 'a', age: 1 },
//           { name: 'b', age: 2 },
//         ],
//         2
//       )
//     );
//   });
// }

//②
//async标记的函数的返回结果 相当于resolve(返回结果)
// export async function fetchMovieInfo(condition) {
//   const result = await getMoviesByPage(condition);
//   return createSetMovieInfoAction(result.movieList, result.movieTotal);
// }

// 方式2：返回一个平面对象，该对象的payload属性为Promise
//该Promise的resolve的结果会作为payload的真实值，然后dispatch分发该payload所在的action
//使用方式二前提：
//action是一个满足Flux标准的action
//1.action是一个plain-object
//2.action.type必须是一个字符串
//3.action属性 必须是规范属性中的一个['type','payload','error','meta']

export function fetchMovieInfo(condition) {
  return {
    type: actionTypes.setMovieInfo,
    payload: getMoviesByPage(condition).then((res) => ({
      movieList: res.movieList,
      movieTotal: res.movieTotal,
    })),
  };
}
```

**store/test.js**

```js
import store from './index';
import { fetchMovieInfo } from './action/movieInfo/searchResult';

store.dispatch(fetchMovieInfo(store.getState().movieInfo.condition));
```

## 手写 redux-promise

```js
import isPlainObject from '../redux/utils/isPlainObject';
import isPromise from 'is-promise';

export default ({ dispatch }) =>
  (next) =>
  (action) => {
    if (isFluxStandardAction(action)) {
      //判断action的payload属性是否是一个promise
      //是：拿到该promise的resolve的结果，作为新的payload，并更新action后，再dispatch分发该action,并不再向后移交该action
      //不是：不做任何处理，直接向后移交该action
      return isPromise(action.payload)
        ? action.payload
            .then((payload) => dispatch({ ...action, payload }))
            .catch((error) =>
              dispatch({ ...action, payload: error, error: true })
            )
        : next(action);
    }
    //判断action是否是一个promise
    //是：拿到该promise的resolve的结果作为action分发dispatch，并不再向后移交该action
    //不是：不做任何处理，直接向后移交该action
    return isPromise(action) ? action.then(dispatch) : next(action);
  };

/**
 * 判断action是否是一个满足Flux标准的action
 * 1.action是一个plain-object
 * 2.action.type必须是一个字符串
 * 3.action属性 必须是规范属性中的一个['type','payload','error','meta']
 * @param {*} action
 * @returns
 */
function isFluxStandardAction(action) {
  return (
    isPlainObject(action) &&
    typeof action.type === 'string' &&
    Object.keys(action).every((key) =>
      ['type', 'payload', 'error', 'meta'].includes(key)
    )
  );
}

```



