# 编译结果分析

## 原始文件

**src/a.js**

```js
console.log('module a');
module.exports = 'a'
```

**src/index.js**

```js
console.log('index module');
var a = require('./a');
a.abc();
console.log(a)
```

## 打包结果

> webpack 会将每个模块（ js 文件）封装到一个对象中，该对象的大体格式如下：
>
> - 对象的每个属性名为独一无二的模块id，通常使用模块路径作为模块id
> - 对象的每个属性值为一个函数，函数体内为模块中书写的代码（**代码放置到 eval 中运行：方便报错调试** ）
>   - sourceURL：配置代码运行报错提示位置，可以配置为开发代码位置方便调错，避免报错位置为打包结果代码
>
>
> ```js
> {
>   "模块路径1":function(){
>     // eval(模块代码... //# sourceURL=webpack:///./src/a.js) 
>   },
>   "模块路径2":function(){
>     // eval(模块代码...)
>   }
> }
> ```
>
> 为了打包结果不污染全局变量， webpack 将打包结果代码放置到一个匿名立即执行函数中运行
>
> 同时 上述封装的对象作为该匿名立即执行函数的参数，以字面量对象形式传入

```js
//合并两个模块
//  ./src/a.js
//  ./src/index.js

(function (modules) {
    var moduleExports = {}; //用于缓存模块的导出结果

    //require函数相当于是运行一个模块，得到模块导出结果
    function __webpack_require(moduleId) { //moduleId就是模块的路径
        if (moduleExports[moduleId]) {
            //检查是否有缓存
            return moduleExports[moduleId];
        }

        var func = modules[moduleId]; //得到该模块对应的函数
        var module = {
            exports: {}
        }
        func(module, module.exports, __webpack_require); //运行模块
        var result = module.exports; //得到模块导出的结果
        moduleExports[moduleId] = result; //缓存起来
        return result;
    }

    //执行入口模块
    return __webpack_require("./src/index.js"); //require函数相当于是运行一个模块，得到模块导出结果
})({ //该对象保存了所有的模块，以及模块对应的代码
    "./src/a.js": function (module, exports) {
        eval("console.log(\"module a\")\nmodule.exports = \"a\";\n //# sourceURL=webpack:///./src/a.js")
    },
    "./src/index.js": function (module, exports, __webpack_require) {
        eval("console.log(\"index module\")\nvar a = __webpack_require(\"./src/a.js\")\na.abc();\nconsole.log(a)\n //# sourceURL=webpack:///./src/index.js")
    }
});
```



