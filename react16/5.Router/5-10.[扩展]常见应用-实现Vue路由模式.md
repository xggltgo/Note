# 实现Vue路由模式

约定：

1. 按照Vue路由模式书写路由配置文件
2. 顶级路由处放置`RouterView`组件，按照路由配置进行匹配
3. 二级路由处，仅需放置`props.children`属性

## 路由配置文件 

```js
import Home from './Home';
import Blog from './Blog';
import BlogList from './BlogList';
import BlogDetail from './BlogDetail';
import About from './About';
import BlogHome from './BlogHome';

export default [
  { name: 'home', path: '/', component: Home },
  {
    name: 'blog',
    path: '/article',
    component: Blog,
    children: [
      {
        name: 'blogHome',
        path: '/',
        component: BlogHome,
      },
      {
        name: 'blogList',
        path: '/list',
        component: BlogList,
      },
      {
        name: 'blogDetail',
        path: '/detail',
        component: BlogDetail,
      },
    ],
  },
  {
    name: 'about',
    path: '/about',
    component: About,
  },
];
```

## 封装RouterView组件

### 组件封装

```js
//RouterView.js

import React from 'react';
import { Route } from 'react-router-dom';
import routeConfig from './routeConfig';

//根据路由配置文件 routeConfig.js 生成对应的Route组件数组
function createRoutes(config, parentPath) { //config(路由配置数组) parentPath（父级路由路径path）
  const routes = config.map((item, index) => {
    let { component: Component, children, path, ...rest } = item; //解构出component属性，以便于后续对有children属性的路由配置对象进行特殊处理；解构出Route组件不需要的children属性；解构出path属性，拼接上父级路由path再传递给Route组件
    path = parentPath + path; //path属性拼接上父级路由path形成最终path属性
    return (形成最终path属性
      <Route
        key={index}         
        path={path}       
        {...rest}            
        exact={children ? false : true}  //此处是否精确匹配需要取决于当前路由配置对象是否没有children属性 防止子级路由匹配不上
        render={() => {  //不直接使用component属性，是因为需要进行判断后匹配不同处理方式的组件
          if (!children) {
            return <Component />;     //当前路由配置对象没有children属性，直接返回该组件
          } else {
            //处理有children属性的情况
            return (
              <Component>
                {/* 生成Route数组 */}
                {createRoutes(children, path)}   //递归生成子级Route组件数组，并作为children属性传递到父级组件中
              </Component>
            );
          }
        }}
      />
    );
  });
  return routes;
}

export default function RouterView() {
  return createRoutes(routeConfig, '');   //首次调用，父级路由路径path为空字符串
}
```

### 组件使用

```js
import React from 'react';
import { BrowserRouter as Router } from 'react-router-dom';
import RouterView from './RouterView';
import './App.css';
import EnhanceLink from './EnhanceLink';

export default function App() {
  return (
    <div>
      <Router>
        <h1>
          <EnhanceLink to={{ name: 'home' }}>Home</EnhanceLink>
          <EnhanceLink to={{ name: 'blog' }}>Blog</EnhanceLink>
          <EnhanceLink to={{ name: 'about' }}>About</EnhanceLink>
        </h1>
        <div>
          <RouterView />
        </div>
      </Router>
    </div>
  );
}

```

## 封装 EnhanceLink组件

### 组件封装

封装EnhanceLink组件的目的：实现匹配组件和地址栏路径的解耦合，使用命名路由进行跳转页面。

**使用**

直接导入 `EnhanceLink`组件替换`Link`组件即可 

区别：除了可以使用 命名路由外，其余使用方式与`Link`组件相同，因为本质上就是对`Link`组件进行了封装。

```js
//EnhanceLink.js

import React from 'react';
import { Link } from 'react-router-dom';
import routeConfig from './routeConfig';

//根据命名路由处配置的名字(name属性) 返回路由配置文件中对应正确path
function hanldeNameToPath(config, parentPath, name) { //config（路由配置数组） parentPath（父级路由路径path）name（命名路由值）
  for (const route of config) { //遍历路由配置数组
    if (route.name === name) {  //若路由配置对象的name属性与命名路由处的name属性值一致
      //匹配成功
      return parentPath + route.path; //返回父级路由path拼接当前路由配置对象path形成最终path属性
    }
    if (route.children) { //如果说当前路由配置对象有children属性 则递归遍历children路由配置数组 继续寻找命名路由
      const pathname = hanldeNameToPath(route.children, route.path, name);
      if (pathname) { //如果找到路由配置对象的name属性与命名路由处的name属性值一致 返回该对应的拼接后的path属性
        return pathname;
      }
    }
  }
}

export default function EnhanceLink(props) {
  const { to, ...rest } = props; //解构出to属性 以便后续对命名路由进行处理（即to.name）
  const pathname = hanldeNameToPath(routeConfig, '', to.name); //根据命名路由处配置的名字(name属性) 返回路由配置文件中对应正确path 首次调用，父级路由路径path为空字符串
  to.pathname = pathname; //将命名路由对应的正确路径 赋值给to.pathname Link组件以便后续进行跳转
  delete to.name; //删除Link组件不需要的to.name
  return <Link to={to} {...rest} />; //返回一个正确配置的Link组件
}
```

### 组件使用

```js
import React from 'react';
import { BrowserRouter as Router } from 'react-router-dom';
import RouterView from './RouterView';
import './App.css';
import EnhanceLink from './EnhanceLink';

export default function App() {
  return (
    <div>
      <Router>
        <h1>
          <EnhanceLink to={{ name: 'home' }}>Home</EnhanceLink>
          <EnhanceLink to={{ name: 'blog' }}>Blog</EnhanceLink>
          <EnhanceLink to={{ name: 'about' }}>About</EnhanceLink>
        </h1>
        <div>
          <RouterView />
        </div>
      </Router>
    </div>
  );
}
```

