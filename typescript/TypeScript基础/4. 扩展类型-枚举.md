# 扩展类型-枚举

> 扩展类型：类型别名、枚举、接口、类 

枚举通常用于约束某个变量、函数参数、函数返回值的**取值范围**

过去，我们将字面量和联合类型配合使用，也能约束某个变量的取值范围

```typescript
let sex: 'male' | 'female'; //字面量和联合类型配合使用,约束sex的取值范围
```
## 字面量类型的问题

1. 在类型约束位置处，会产生重复代码。

   1. 过去，我们可以使用类型别名解决重复代码的问题

2. 逻辑含义和真实值产生了混淆，会导致当修改真实值的时候，产生大量的修改

   ```typescript
   //由于没有实现逻辑含义和真实值的解耦合，如果某天需要进行修改'男'为'先生'的话，则会导致系统中大量Sex类型的值需要修改
   type Sex = '男' | '女';
   const a: Sex = '男';
   const b: Sex = '男';
   const c: Sex = '男';
   const d: Sex = '男';
   const e: Sex = '男';
   //...
   ```

3. 字面量类型不会进入到编译结果

## 枚举的使用

如何定义一个枚举（枚举字段则表示逻辑含义，值则表示真实值）

注意：后续我们应该以`枚举名.枚举字段`的方式去使用，来实现逻辑含义和真实值的解耦合。

```typescript
enum 枚举名{
  枚举字段1 = 值1,
  枚举字段2 = 值2,
  ...
}
```

 枚举会出现在编译结果中，且在编译结果中表现为对象（因此，可以在ts代码中使用该对象，例如遍历该对象的属性值）**index.ts**

```typescript
enum Sex {
  male = '男', //使用枚举，如果某天需要修改'男'为'先生'的话，仅需要修改此处的值即可（前提：后续应该以`枚举名.枚举字段`的方式去使用值）
  female = '女',
}

const a: Sex = Sex.male;
const b: Sex = Sex.male;
const c: Sex = Sex.male;
const d: Sex = Sex.male;
const e: Sex = Sex.male;

const sexVals = Object.values(Sex); //由于枚举会出现在编译结果中且表现为对象，因此我们可以使用该对象
sexVals.forEach((val) => {
  console.log(val); //男 女
});
```

编译后的结果：**index.js**

```js
var Sex;
(function (Sex) {
    Sex["male"] = "\u7537";
    Sex["female"] = "\u5973";
})(Sex || (Sex = {}));
/* 
上面立即执行函数最终生成一个对象Sex
{
    male:"男"，
    female:"女"，
}
*/ 
const a = Sex.male;
const b = Sex.male;
const c = Sex.male;
const d = Sex.male;
const e = Sex.male;
const sexVals = Object.values(Sex);
sexVals.forEach((val) => {
    console.log(val);
});
```

枚举的规则：

1. 枚举的值可以是字符串或者数字

2. 数字枚举（枚举的值全是数字）的值会自动自增，默认起始值为0

3. 被数字枚举约束的变量，可以直接赋值为数字(为了实现逻辑含义和真实值的解耦合，不推荐这样做)

4. 数字枚举的编译结果 和 字符串枚举的编译结果有差异

   **index.ts**

   ```typescript
   enum Level {
     level1,  //默认起始值为0 相当于书写了 `level1 = 0`的代码
     level2,
     level3,
   }
   ```

   编译后：**index.js**
   ```js
   var Level;
   (function (Level) {
     Level[(Level['level1'] = 0)] = 'level1';
     Level[(Level['level2'] = 1)] = 'level2';
     Level[(Level['level3'] = 2)] = 'level3';
   })(Level || (Level = {}));
   /*
   以上立即执行函数最终形成的对象Level：
   {
       level1:0,
       level2:1,
       level3:2,
       '0':'level1',
       '1':'level2',
       '2':'level3',
   }
   */
   ```

**最佳实践：**

1. 尽量不要在一个枚举中既出现字符串值，又出现数字值
2. 使用枚举时，尽量使用`枚举名.枚举字段`的形式，而不是直接使用真实值



## 扩展知识：枚举的位运算

枚举的位运算，仅针对数字枚举

位运算：两个数字换算成二进制后进行的运算 

| 类型 | 含义            | 举例                 |
| ---- | --------------- | -------------------- |
| \|   | 或              | 0010 \| 0001 -> 0011 |
| &    | 与              | 0010 & 1010 -> 0010  |
| ^    | 异或（相异为1） | 0010 & 1010 -> 1101  |

**假设我们有一个需要分配权限的场景：**

```typescript
enum Permission {
  read,
  write,
  create,
  delete,
  //若需要进行权限的组合 无脑的处理办法:
  readAndWrite,
  readAndCreate,
  readAndWriteAndCreate,
  //...
}
```

**利用枚举的位运算的处理办法：**

```typescript
enum Permission {
  read = 1, //0001
  write = 2, //0010
  create = 4, //0100
  delete = 8, //1000
}

//1.组合（添加）权限
/*
读    0001
写    0010
|    或运算
读写  0011
*/
let p: Permission = Permission.read | Permission.write; // 3 ->0011

//2.判断target是否拥有某个权限
function hasPermission(target: Permission, permission: Permission) {
  return (target & permission) === permission;  
}
/*
p的权限  0011
读      0001
&      与运算
        0001
*/
const result = hasPermission(p, Permission.read);
console.log(result); //true

//3.移出某个权限
/*
p的权限    0011
读        0001
^      异或运算
p新的权限  0010
*/
p = p ^ Permission.read; 
console.log(hasPermission(p, Permission.read)); //
```

