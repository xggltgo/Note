# 手写connected-react-router

- connectRouter：函数，返回一个reducer
- routerMiddleware：函数，返回一个中间件
- ConnectedRouter：组件，提供路由信息上下文，类似于BrowserRouter、HashRouter。。。
- 一些action-creators:
  - push
  - replace

**index.js**

集中导出模块

```js
export { default as connectRouter } from './connectRouter';
export { push, replace } from './actionCreators';
export { default as routerMiddleware } from './routerMiddleware';
export { default as ConnectedRouter } from './ConnectedRouter';
```

**connectRouter.js**

connectRouter（history）

- 函数，接收一个参数（history对象），用于获取reducer的初始状态
- 返回一个reducer

```js
import { LOCATION_CHANGE } from './actionTypes';

/**
 * 约定payload的格式
 * {
 *  action:'PUSH',
 *  location:{...}
 * }
 */

export default function (history) {
  const initial = {
    action: history.action,
    location: history.location,
  };
  //返回一个reducer
  return function (state = initial, { type, payload }) {
    switch (type) {
      case LOCATION_CHANGE:
        return payload;
      default:
        return state;
    }
  };
}
```

**actionTypes.js**

导出两种不同类型

- LOCATION_CHANGE：该action类型用于reducer管理仓库中的数据
- CALL_HISTORY_METHOD：该action类型用于routerMiddleware中间件，特殊处理（跳转页面）

```js
export const LOCATION_CHANGE = '@@router/LOCATION_CHANGE';
export const CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';
```

**actionCreators.js**

导出一些action创建函数

- push：如下注释
- replace：同push注释
- createPageChangeAction：返回一个页面改变后，需要分发的action

```js
import { CALL_HISTORY_METHOD, LOCATION_CHANGE } from './actionTypes';

/**
 * push是一个action创建函数，返回一个action。
 * 返回的action类型应当是一个特殊的actionType，以供routerMiddleware中间件处理
 * payload标注使用的方法和参数，以供routerMiddleware中间件调用history对象中对应的方法并传入参数
 * @param  {...any} args
 */
export function push(...args) {
  return {
    type: CALL_HISTORY_METHOD,
    payload: {
      method: 'push',
      args,
    },
  };
}

export function replace(...args) {
  return {
    type: CALL_HISTORY_METHOD,
    payload: {
      method: 'replace',
      args,
    },
  };
}

export function createPageChangeAction(location, action) {
  return {
    type: LOCATION_CHANGE,
    payload: {
      location,
      action,
    },
  };
}
```

**routerMiddleware.js**

核心思想：如注释

```js
import { CALL_HISTORY_METHOD } from './actionTypes';

/**
 * routerMiddleware核心思想（与redux-chunk核心思想类似）：
 * 中间件在处理action.type=CALL_HISTORY_METHOD的时候；
 * 会调用history对象中的对应api进行跳转页面，同时不会将这个特殊的action类型向后移交
 */
export default (history) => (store) => (next) => (action) => {
  if (action.type === CALL_HISTORY_METHOD) {
    //1.调用history对象方法
    const { method, args } = action.payload;
    history[method](...args);
  } else {
    next(action);
  }
};
```

**ConnectRouter.js**

核心思想：如注释

```js
//无论是通过哪种方式跳转页面 NavLink或者通过分发特殊的action跳转页面
//我们都需要在跳转页面后，分发LOCATION_CHANGE的action类型
//这样reducer才能处理，同时redux-devtools才能检测到
//因此我们需要利用history.listen监听地址变化，因此需要与routerMiddleware、connectRouter使用同一个history对象
//然后手动触发action类型为LOCATION_CHANGE的action

import React, { Component } from 'react';
import { Router } from 'react-router-dom'; //导入Router以提供与BrowserRouter相同的功能
import { ReactReduxContext } from 'react-redux'; //导入react-redux提供的含有store对象的上下文，用于分发action
import { createPageChangeAction } from './actionCreators'; 

export default class ConnectedRouter extends Component {
  static contextType = ReactReduxContext;

  componentDidMount() {
    this.history = this.props.history;
    this.unlisten = this.history.listen((location, action) => {
      //手动触发action类型为LOCATION_CHANGE的action
      this.context.store.dispatch(createPageChangeAction(location, action));
    });
  }

  componentWillUnmount() {
    this.unlisten && this.unlisten();
  }

  render() {
    return <Router history={this.props.history}>{this.props.children}</Router>;
  }
}
```

