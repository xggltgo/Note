# 导航守卫

**导航守卫：当离开一个页面，进入另一个页面时，触发的事件**

## 知识提要

**history对象**

- listen: 添加一个监听器，监听地址的变化，当地址发生变化时，会调用传递的函数
  - 参数：函数，运行时间点：发生在即将跳转到新页面时
    - 参数1：location对象，记录当前的地址信息
    - 参数2：action，一个字符串，表示进入该地址的方式
      - POP：出栈
        - 通过点击浏览器后退、前进
        - 调用history.go
        - 调用history.goBack
        - 调用history.goForward
      - PUSH：入栈
        - history.push（`Link`组件本质也是使用该方法）
      - REPLACE：替换
        - history.replace
  - 返回结果：函数，可以调用该函数取消监听
  
- block：设置一个阻塞，并同时设置阻塞消息，当页面发生跳转时，会进入阻塞，并将阻塞消息传递到路由根组件的getUserConfirmation方法。

  - 字符串消息（block函数传递一个字符串）
  - 函数，函数的返回结果是一个字符串，用于表示阻塞消息（block函数传递一个函数）
    - 参数1：location对象
    - 参数2：action值

  - 返回一个回调函数，用于取消阻塞器

**路由根组件`BrowserRouter`  方法getUserConfirmation** （该方法需要与block阻塞连用，设置阻塞后才会调用该方法）

- 参数：函数
  - 参数1：阻塞消息
  - 参数2：回调函数，调用该函数并传递true，则表示进入到新页面，否则，不做任何操作

## 封装 RouteGuard组件

### 组件封装

```js
//RouteGuard.js

import React, { Component } from 'react';
import { BrowserRouter as Router, withRouter } from 'react-router-dom';

let prevLocation, nextLocation, action, unBlock;
class _GuardHelper extends Component {  //内部辅助组件 用于获取history对象 以触发阻塞block和添加监听listen
  componentDidMount() {
    this.unBlock = this.props.history.block((location, ac) => { //触发阻塞 并保存prevLocation（跳转前的location信息）、nextLocation（跳转后的location信息）、action（跳转方式）、unBlock（销毁阻塞）到全局变量。以便后续作为参数传递给开发者使用
      prevLocation = this.props.location;
      nextLocation = location;
      action = ac;
      unBlock = this.unBlock;
      return '';
    });

    this.unListen = this.props.history.listen((location, action) => { //添加监听 ...
      this.props.onChange &&
        this.props.onChange(
          this.props.location,
          location,
          action,
          this.unListen
        );
    });
  }

  componentWillUnmount() { //组件销毁 一并销毁阻塞和取消监听
    this.unListen();
    this.unBlock();
  }

  render() {
    return null; //辅组组件 无需渲染
  }
}

const GuardHelper = withRouter(_GuardHelper); // 利用withRouter 以便获得路由信息 拿到history对象

export default class RouteGuard extends Component {
  hanldeRouteConfirmation = (msg, confirm) => {  //处理拦截器 调用开发者传递的函数，并给予全局变量中保存的信息供开发者使用
    if (this.props.onBeforeEnter) {
      this.props.onBeforeEnter(
        prevLocation,
        nextLocation,
        action,
        confirm,
        unBlock
      );
    } else {
      confirm(true); //若没有传递拦截器处理函数 默认允许跳转
    }
  };

  render() {
    return (
      <Router getUserConfirmation={this.hanldeRouteConfirmation}>
        <GuardHelper onChange={this.props.onChange} />  {/*辅助组件*/}
        {this.props.children} 
      </Router>
    );
  }
}
```

### 组件使用

RouteGuard组件 提供 onBeforeEnter（拦截器）、onChange（监听器）供开发者按需使用。

```js
import React from 'react';
import Page1 from './Page1';
import Page2 from './Page2';
import RouteGuard from './RouteGuard';
import { Link, Route } from 'react-router-dom';
import './App.css';

export default function App() {
  return (
    <div>
      <RouteGuard
        onBeforeEnter={(
          prevLocation,
          nextLocation,
          action,
          confirm,
          unBlock
        ) => {
          console.log(
            `页面从${prevLocation.pathname}跳转到${nextLocation.pathname},方式为${action}`
          );
          confirm(true);
          unBlock();
        }}

        onChange={(prevLocation, nextLocation, action, unListen) => {
          console.log(
            `listen：页面从${prevLocation.pathname}跳转到${nextLocation.pathname},方式为${action}`
          );
          unListen();
        }}
      >
        <h1>
          <Link to="/page1">Page1</Link>
          <Link to="/page2">Page2</Link>
        </h1>
        <div>
          <Route path="/page1" component={Page1}></Route>
          <Route path="/page2" component={Page2}></Route>
        </div>
      </RouteGuard>
    </div>
  );
}
```

