# 吃透面试之每日两题

## 网络

### [01 五层网络模型](E:\help file\xgglt\笔面试\Network\01 五层网络模型.md)

> 谈谈五层网络模型。
>
> 我所了解到的五层网络模型，从上到下分别为：应用层、传输层、网络层、数据链路层和物理层。
>
> 其中：
> 1. 应用层主要面向的是互联网中的应用场景，比如网页、邮件、文件中心等，它的代表协议有 http、websocket、smtp（发送邮件）、pop3（接收邮件）、ftp（文件共享）、DNS（域名解析） 等等
> 2. 传输层主要面向的是传输过程，它的代表协议有TCP 、UDP 等。TCP 协议是保证消息可靠的传输，而 UDP 协议则是一种无连接的广播（直播场景）。
> 3. 网络层主要解决如何在互联网中定位目标以及如何寻找最优路径的问题。它的代表协议有IP协议，同时，我们平时常用的路由器也是属于网络层的设备。
> 4. 数据链路层主要的作用是保证数据在一个广播域，或者说是在一个子网内的有效传输，电脑的MAC地址（一张网卡对应一个MAC地址）和交换机都是属于数据链路层的设备
> 5. 物理层主要是要解决二进制数据与信号之间的互转问题，光纤、双绞线、集线器、同轴电缆等都是属于物理层的设备

### 03 cookie

> 谈谈 cookie。
>
> 

### [06 jwt](E:\help file\xgglt\笔面试\Network\06 jwt.md)

> 谈谈 jwt。
>
> JWT 全称`Json Web Token`，是一种统一的、安全的令牌格式。
>
> 其实，本质就是一个字符串，我们通常利用它来进行用户认证。
>
> JWT的核心原理：当登录成功后，服务器给客户端响应一个JWT。客户端收到服务器响应的 JWT，可以储存在 Cookie 中，也可以储存在 localStorage中。此后，客户端每次与服务器通信，都需要附带上服务器颁发的 JWT。如果JWT储存在 Cookie 中，浏览器自动发送即可。如果JWT储存在 localStorage中，我们往往会将 JWT 放到请求头的`Authorization`字段中，并规范其格式为 bearer `空格` 拼接上 JWT。服务器从请求头中获取 JWT ，并验证其有效性即可。
>
> 令牌的组成：
>
> `header.payload.signature`
>
> `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9.BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc`
>
> header：令牌头部，记录了令牌类型和签名算法；（`base64 url`编码）
>
> payload：令牌负荷，记录主体信息，包含令牌过期时间、发布时间、发行者、主体内容等；（`base64 url`编码）
>
> signature：令牌签名，按照头部固定的签名算法对整个令牌进行加密，保证JWT不被篡改（原因：攻击者拿不到密钥，密钥仅存服务器被内部）

### [16 TCP协议](E:\help file\xgglt\笔面试\Network\16 TCP协议.md)

 > 谈谈你对 TCP 三次握手和四次挥手的理解。
 >
 > TCP协议要求：接收方收到数据报后，必须对数据报进行确认！（ACK包）
 >
 > TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：
 >
 > 首先服务器进入监听状态，然后即可处理连接
 >
 > 第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。
 >
 > 第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。
 >
 > 第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。
 >
 > 最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成
 >
 > 当需要关闭连接时，需要进行四次挥手才能关闭
 >
 > 1. Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。
 > 2. Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。
 > 3. Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。
 > 4. Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。
 > 5. Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。
 > 6. Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。

### [18 XSS攻击](E:\help file\xgglt\笔面试\Network\18 XSS攻击.md)

> 谈谈XSS攻击。
>
> XSS攻击，全称`Cross Site Scripting`，表示跨站脚本攻击。跨站脚本攻击是指攻击者利用系统的漏洞，在表单提交时，向表单中注入一些恶意的脚本代码，当普通用户正常浏览页面时，攻击者所注入的恶意脚本代码被执行，导致页面被破坏，或者用户信息被窃取。这就是XSS攻击。
>
> 对于XSS攻击的防范方式，一般是在服务器端进行处理。服务器端对于XSS攻击的防范方式一般有两种，过滤或编码。
>
> 过滤是指，服务器端会自定义一些危险的标签和危险的属性。对于用户所提交的内容，会过滤掉这些危险的标签和属性。
>
> 编码是指，对用户提交的内容进行html实体编码。比如，左尖角号会被编码成&lt,右尖角号会被编码成&gt

### [23 HTTP版本差异](E:\help file\xgglt\笔面试\Network\23 HTTP版本差异.md)

> HTTP1.0：
>
> - 无法复用TCP连接（HTTP1.0为每个请求单独新开一个TCP连接）
> - 队头阻塞（如果前一个请求被某种原因阻塞了，会导致后续请求无法发送）
>
> HTTP1.1：
>
> - 长连接（HTTP1.1默认开启长连接`Connection:keep-alive`，在这种情况下，多次请求响应可以共享同一个TCP连接，这不仅减少了TCP的握手和挥手时间，同时可以充分利用TCP「慢启动」的特点，有效的利用带宽）
> - 管道化和队头阻塞（HTTP1.1允许在响应到达之前发送下一个请求，这样可以大幅缩减带宽限制时间，但由于服务器必须按照请求到达的顺序进行响应，因此仍然存在队头阻塞的问题）
>
> HTTP2.0
>
> - 二进制分帧（将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装）
> - 多路复用（基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序）
> - 头部压缩（http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量）
> - 服务器推（服务器能够主动推送静态资源到客户端，适用于资源的预加载等场景）
>
> HTTP3.0
>
> - 由于 TCP 协议本身面对网络丢包时可能会导致对头阻塞问题，HTTP3.0完全抛弃了 TCP 协议，转而使用 UDP 协议
> - 为了保证传输的可靠性，HTTP3.0使用了 QUIC 协议。

### [24 WebSocket](E:\help file\xgglt\笔面试\Network\24 WebSocket.md)

> 谈谈 WebSocket。
>
> WebSocket 协议 是 HTML5 带来的新协议，它通常应用于实时场景或双向通信场景。在过去，由于 Http 协议的种种限制，面对实时场景，我们往往只能通过短轮询（short polling）或者是长轮询（long polling）来进行处理。但无论是短轮询还是长轮询，面对实时场景都存在明显的缺陷，其本质是因为 HTTP 协议是请求-响应模式，请求必须在前，响应必须在后，这就导致了服务器无法「主动」的把消息发送给客户端。WebSocket  的出现就是为了解决这个问题。
>
> 相对于 Http 协议，WebSocket 协议是一个持久连接的协议，它建立在 TCP 协议之上，其本质利用的是 TCP 的全双工通信的能力。
>
> 使用WebSocket，会经历两个阶段：握手阶段、通信阶段
>
> - 握手阶段
>
>   当客户端需要和服务器使用WebSocket进行通信时，首先会使用HTTP协议完成一次特殊的请求-响应，这一次请求-响应就是WebSocket的握手阶段。
>
>   - 首先，此次 HTTP 请求的协议名需要修改为 ws 或 wss
>   - 其次，需要在请求头中添加 `Connection`、`Upgrade`、`Sec-WebSocket-Version`、`Sec-WebSocket-Key`等字段
>   - 服务器受到请求后，发现这是一个 websocket 协议的握手请求，于是响应状态码为 101 ，同时响应行中还包含`Switching Protocols`，表示切换协议，其次还会向响应头中添加`Connection`、`Upgrade`、`Sec-WebSocket-Accept`等字段
>   - 当客户端收到响应后即完成握手，随后使用建立的 TCP 连接直接发送和接收消息即可。
>   
> - 通信阶段
>
>   消息收发不再使用HTTP，任何一方都可以主动发消息给对方

## 浏览器

### 01 浏览器渲染流程 ⭐

> 谈谈浏览器的渲染流程。
>
> 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。
>
> 整个渲染流程分为多个阶段，分别是：解析 HTML、样式计算、布局、分层、绘制、分块、光栅化、画
>
> - 解析 HTML
>   - 为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。
>   - 如果主线程解析到`link`位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。
>   - 如果主线程解析到`script`位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。
>   - 第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。
> - 样式计算
>   - 主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。
>   - 在这一过程中，很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px`
>   - 这一步完成后，会得到一棵带有样式的 DOM 树。
> - 布局
>   - 布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。
>   - 大部分时候，DOM 树和布局树并非一一对应。
>   - 比如`display:none`的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。
> - 分层
>   - 主线程会使用一套复杂的策略对整个布局树进行分层。
>   - 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。
>   - 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。
> - 绘制
>   - 主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。
>   - 完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。
> - 分块
>   - 合成线程首先对每个图层进行分块，将其划分为更多的小区域。
>   - 它会从线程池中拿取多个线程来完成分块工作。
> - 光栅化
>   - 合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。
>   - GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。
>   - 光栅化的结果，就是一块一块的位图
> - 画
>   - 合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。
>   - 指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。
>   - 变形发生在合成线程，与渲染主线程无关，这就是`transform`效率高的本质原因。
>   - 合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。

> 谈谈重绘和回流（重排）。
>
> **回流一定导致重绘，重绘不一定导致回流**
>
> 回流通常是指元素的尺寸、位置发生改变后导致重新布局，而重新布局后则需要重新获取各个元素的像素信息。因此，回流一定导致重绘
>
> 重绘通常是指元素的外观发生改变，比如修改背景颜色，而修改背景颜色并不会导致元素的尺寸、位置发生变化。因此，重绘不一定导致回流。
>
> 现代浏览器会通过队列化修改并批量执行来优化重排过程。只有达到一定时间或者操作达到阈值，才会清空队列。但是，获取布局信息时，会强制队列刷新。
>
> 减少回流和重绘的方式？
>
> 1. 在给同一个元素设置多个可能引发回流的样式时，优先考虑使用cssText或者添加一个类样式来替代多个行内样式代码。
> 2. 如果需要给父元素批量添加子元素时，可以先使父元素脱离文档流，在批量添加子元素后再将父元素带回到文档流中。
>
> - 隐藏元素，批量添加，重新显示
>
> - 利用文档片段（ document fragment ）批量添加子元素后，再将文档片段插入父元素。
>
> 3. 用变量保存元素的布局信息，避免频繁获取布局信息导致多次回流
> 4. 复杂动画使用绝对定位脱离文档流，避免导致回流
> 5. 多使用CSS3的transform、opacity、filters等属性，由于CSS3的硬件加速，上述属性不会引起回流。

> 为什么 transform 的效率高？
>
> 因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段
>
> 由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。

> 什么是 reflow？
>
> reflow 的本质就是重新计算 layout 树。
>
> 为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。
>
> 也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。
>
> 因此，浏览器在反复权衡下，最终决定获取属性立即 reflow。

> 什么是 repaint？
>
> repaint 的本质就是重新根据分层信息计算了绘制指令。
>
> 当改动了可见样式后，就需要重新计算，会引发 repaint。
>
> 由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。02 资源提示关键词

### [02 资源提示关键词](E:\help file\xgglt\笔面试\Browser\02 资源提示关键词.md)

> 谈谈资源提示关键词。
>
> 当浏览器正在构建 DOM 时，如果遇到了 `<script>...</script>` 标签，会停止构建DOM，转而去执行脚本代码。如果脚本代码是外部的，则还需要先下载脚本再执行。执行完对应的脚本代码后呢，再接着构建DOM。
>
> CSS不会直接影响DOM的构建，但如果`script`脚本代码中需要访问或使用CSSOM树中的内容，那么构建对应CSSOM树的过程会阻塞`script`脚本的执行，从而间接的阻塞了DOM的构建。
>
> 为了避免CSS阻塞JS的执行或者导致Flash of Unstyled Content（无样式内容闪现）。因此，“顶部样式，底部脚本”成为了“最佳实践”。
>
> async 下载 JS 文件的时候不会阻塞 DOM 树的构建，但是执行该 JS 代码会阻塞 DOM 树的构建
>
> defer 下载 JS 文件的时候不会阻塞 DOM 树的构建，然后会等待 DOM 树构建完毕后再去执行下载的 JS 文件
>
> preload 预加载 向浏览器声明一个需要提前加载的资源 当资源真正需要使用时，就无需再等待资源的加载。（使用link标签，rel属性指定preload，as指定资源类型（style或者是script））
>
> prefetch 利用浏览器的空闲时间加载页面将来可能用到的资源,通常可以用于加载非首页的其他页面所需要的资源，以便加快后续页面的首屏速度
>
> prerender prerender 与 prefetch 非常相似,不过它会在后台渲染整个页面。
>
> preconnect preconnect 指令允许浏览器在 HTTP 请求实际发送到服务器之前设置早期连接 比如DNS查找、TCP三次握手等

### 03 浏览器的组成部分

> 浏览器的组成部分。
>
> 用户界面（*user interface*）。用户界面用于呈现浏览器窗口部件，比如地址栏、前进后退按钮、书签等
>
> 浏览器引擎（*browser engine*）。*UI*（用户界面） 和渲染引擎之间的桥梁。接收来自 *UI* 的输入，然后通过操纵渲染引擎将对应的资源显示在浏览器中。
>
> 渲染引擎（*rendering engine*）。又被称作浏览器内核。完成浏览器的整个渲染流程。
>
> 网络（*networking*）。处理浏览器内的各种网络通信。
>
> JS 解释器（*JavaScript interpreter*）。JS引擎。
>
> 用户界面后端（*UI backend*）。向下调用操作系统，向上提供一些部件的接口，比如单选框、多选框、下拉列表等。
>
> 数据存储（*data storage*）。用于浏览器在本地保存各种数据。


### [08 浏览器缓存](E:\help file\xgglt\笔面试\Browser\08 浏览器缓存.md) ⭐⭐

> 介绍一下浏览器缓存。
>
> 我先简单说一下浏览器缓存的核心原理吧：浏览器每次请求资源，都会优先查找缓存，如果缓存中有对应的资源，则直接使用缓存中的资源。如果缓存中没有对应的资源，才会发送真实的请求到服务器，服务器再返回对应的资源给浏览器。
>
> 同时，浏览器的缓存按照不同的缓存位置分为了不同的类型，并且它们各自拥有不同的优先级，只有按照优先级顺序依次查找缓存且都没有命中的时候，才会发送真实的请求到服务器。
>
> 首先，浏览器会去查找 Service Worker ，Service Worker它并不是浏览器自发的缓存行为，而是需要我们开发者自行注册Service Worker，并且自行控制缓存规则。（其核心是拦截请求后，查询是否存在缓存，由于涉及请求拦截，为了保障安全，所以传输协议必须是https）
>
> 如果没有命中 Service Worker ，然后浏览器会去查找 Memory Cache，也就是内存缓存，内存缓存的话，大多是缓存的是一些资源的引用。
>
> 如果没有命中 Memory Cache，然后浏览器会去查找 Disk Cache，也就是磁盘缓存。同时也被称为Http Cache。Disk Cache按照缓存类型可以分为强制缓存和协商缓存。
>
> 强制缓存：当我们第一次向服务器发送请求后，服务器会响应对应的资源和缓存指令。当浏览器识别缓存指令后，就会自发的将响应的资源缓存起来。所谓缓存指令，无非是一些特殊的响应头(`Cache-Control(Expires)`、`ETag`、`Date` 、`Last-Modified`)。
>
> 协商缓存：可以理解为强制缓存失效后的处理方案，缓存内容是否失效由服务器决定。浏览器携带缓存标识（特殊的请求头`If-None-Match（http1.1）`、`If-Modified-Since（http1.0）`）发送请求到服务器，服务器内部判断资源是否变化。如果服务器表示：我这边资源没有改变，你可以继续使用，则仅响应状态码为304和新的缓存指令供浏览器更新缓存时间。如果，服务器表示：资源确实改变了，则响应状态码为200和新的资源及新的缓存指令供浏览器更新缓存。
>
> 最后，如果没有命中 Disk Cache ,然后浏览器会去查找 Push Cache,也就是推送缓存（HTTP/2中新增的内容）

### 事件循环 ⭐⭐⭐

> 面试题：阐述一下 JS 的事件循环
>
> 参考答案：
>
> 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。（**单线程是异步产生的原因，事件循环是异步的实现方式**）
>
> 在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。
>
> 过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
>
> 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。

## JavaScript

### [01 var、let、const的区别](E:\help file\xgglt\笔面试\JavaScript\01 let、var、const的区别.md) ⭐

> *let const var* 的区别？什么是块级作用域？如何用？
>
> 1. var声明变量不会产生块级作用域，let、const声明变量会产生块级作用域。块级作用域：代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域。
> 2. var、let声明变量时，不初始化值默认为 *undefined*。const用于声明常量，声明时必须立即赋值，且所赋的常量值不能改变。（常量不可变，是指声明的常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变）
> 3. var存在变量声明提升，变量声明会被提升到作用域的顶端。let、const“不存在变量提升”（底层实现上，let声明的变量实际上也会有提升，但是，提升后会将其放入到“**暂时性死区**”，**如果访问的变量位于暂时性死区，则会报错：“Cannot access 'a' before initialization”**。**当代码运行到该变量的声明语句时，会将其从暂时性死区中移除**。）（暂时性死区：运行流程进入作用域创建变量，到变量进行词法绑定（可以被访问之间）的这一段时间，就称之为暂时死区）
> 4. var同一作用域中允许重复声明，let、const同一作用域中不允许重复声明
> 5. 全局作用域用 *var* 声明的变量会挂载到 *window* 对象下，let、const则不会。


### 03 包装类型

> 是否了解 *JavaScript* 中的基本包装类型？
>
> 基本包装类型是，每当我们去读取一个基本数据类型的值，或者是将基本数据类型以对象的形式去使用时，JS就会在内部创建其对应的基本包装类型的临时对象，以至于我们可以使用该临时对象上的内置方法，从而我们可以对string、number、boolean这三种基本数据类型的数据进行更多的操作。注意：读取或操作基本数据类型的值的语句一经执行完毕，内部就会立即销毁基本包装类型的临时对象。

### 02 值和引用

> *JS* 的基本数据类型有哪些？基本数据类型和引用数据类型的区别
>
> 基本数据类型，一共有7种,分别是string，number，boolean，undefined，null，symbol，BigInt
>
> 基本数据类型和引用数据类型的区别：
>
> 基本数据类型的值又被称为原始值或简单值，是表示 JS中数据的最底层形式，是不可再进行细化的。因此基本数据类型的值的数据大小是固定的，它们被存放在内存中的栈区。
>
> 引用数据类型的值又被称为引用值或复杂值。是能够进行细化的，可以向下拆分为多个简单值或者复杂值。因此复杂值在内存中的大小是未知的，因此复杂值的数据都是存放在内存中的堆区。栈区仅存放地址。
>
> 另外，由于历史原因所遗留下来的问题，基本数据类型中的null比较特殊，typeof null等于object。（具体原因是JavaScript中对象在底层都表现为二进制，而在 JavaScript 中二进制前三位都为 0 的话就会被判断为 object 类型，null 的二进制全部为 0，所以 typeof null会返回 object）这是JavaScript从第一个版本开始就有的一个bug，并且为了兼容现有代码，该bug不能被修复。



### [06 原型与原型链](E:\help file\xgglt\笔面试\JavaScript\06 原型和原型链.md) ⭐⭐

> 说一说你对 *JavaScript* 中原型与原型链的理解？
>
> 当访问对象某个成员时，会首先看对象自身是否有该成员，如果没有的话，就会到该对象的原型链上依次查找。
>
> new 一个构造函数会产生一个该构造函数的实例对象，该实例对象的隐式原型则指向了构造函数的原型对象。而构造函数的原型对象又是通过 new Object 产生的，因此构造函数的原型对象的隐式原型又指向了 Object 的原型对象，而 Object 的原型对象的隐式原型指向null。而无论是Object函数还是构造函数它们都是通过new Function产生的，因此它们的隐式原型又指向了Function的原型对象，Function的原型对象是通过new Object 产生的，因此Function的原型对象的隐式原型指向了Object的原型对象，Function构造函数的隐式原型比较特殊指向的是Function的原型对象。

### 08 作用域和作用域链

> 谈谈你对作用域和作用域链的理解？
>
> 在JS中，有三种作用域，分别是全局作用域、函数作用域、块级作用域。
>
> 作用域的特点：
> - 内部的作用域能访问外部，反之不行。访问时从内向外依次查找。
> - 如果在内部的作用域中访问了外部，则会产生闭包。
> - 内部作用域能访问的外部，取决于函数定义的位置，和调用无关
> - 作用域内定义的变量（var定义）、函数声明会提升到作用域顶部

### [09 *this* 指向](E:\help file\xgglt\笔面试\JavaScript\09 this指向.md) ⭐

> 谈谈this指向。
>
> 在不同的场景下，JS 中的 this 指代的含义不尽相同。
>
> 在全局代码中使用 this，则 this 指代全局对象。不过在真实的开发中，我们几乎不会在全局代码使用 this。
>
> 在函数中使用 this 的话，它的指向完全取决于函数是如何被调用的。
>
> 如果函数是被直接调用，则在非严格模式下 this 指向全局对象，在严格模式下则指向 undefined 。
>
> 如果函数是通过对象.方法进行调用的话，则函数中的this指向.前面的对象
>
> 如果函数是通过 new 方法进行调用的话，则函数中的 this 指向新的实例对象
>
> 如果是事件处理函数中的 this ， 则指向注册事件的 dom 元素
>
> 另外，我们可以通过 call 、apply 、bind 方法改变 this 指向。
>
> call方法本质是改变 this 指向，然后调用该函数，即 call 方法的第一个参数为 this  指向的对象，如果参数为空或null、undefind，则this指向全局对象（apply、bind也是一样）。如果call方法的第一个参数为原始数据类型，则内部会转化成对应的包装对象后再传入call方法。同时，call方法可以接收多个参数，第一个参数是 this 指向的对象，其余参数依次作为函数执行时的参数。
>
> apply方法 和 call方法 作用类似，也是改变 this 指向，然后调用该函数，唯一区别是 apply 接收数组作为函数执行时的参数。
>
> bind方法的本质是将函数体内的 this 绑定到某个对象，然后返回一个新函数。bind绑定后，函数内部this不再取决于函数是如何被调用的，而是固定为了绑定的对象（直接绑死）。bind方法也可以接收多个参数，第一个参数为this绑定的对象，其余参数依次绑定到原函数的参数。可以理解为实现了类似函数柯里化的功能。
>
> 箭头函数的 this 始终指向外层作用域。

### [10 垃圾回收与内存泄漏](E:\help file\xgglt\笔面试\JavaScript\10 垃圾回收与内存泄漏.md) ⭐

> 请介绍一下 *JavaScript* 中的垃圾回收机制。
>
> JavaScript 中的垃圾回收机制，主要是为了解决 `内存泄漏(不再用到的内存没有被及时释放)` 的问题。
>
> JavaScript 具有自动的垃圾回收机制。垃圾回收器会定期的找出那些 `不再继续使用的变量(只可能是局部变量,全局变量的生命周期直至浏览器卸载页面才会结束)` ，并释放其内存。
>
> JavaScript 常见的垃圾回收方式：标记清除和引用计数。
>
> 标记清除（多数浏览器的垃圾回收策略）。垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量所引用的变量的标记（闭包）。最后，仍被标记的变量，即垃圾回收器需要回收的变量。
>
> 引用计数。记录每个值被持有引用的数量，垃圾回收器仅回收被持有引用数量为0的变量的内存。正因为如此，引用计数方式就会有一个弊端，即循环引用。比如：两个对象的不同属性分别持有，另一个对象的引用。那么，就会导致该两个对象所享有的内存，永远不会被垃圾回收器回收。

### 20 函数防抖和节流 

> 防抖，节流是什么，如何实现?
>
> 无论是函数防抖，还是函数节流，其本质上都是为了避免某个函数频繁运行。在日常的应用场景中往往是一些事件处理函数频繁运行，比如文本框的`input`事件、滚动条的滚动事件、window的resize事件、某个元素的mousemove事件等等。而函数防抖和函数节流的作用，就是为了避免此类函数频繁运行。

### [22 深浅拷贝](E:\help file\xgglt\笔面试\JavaScript\22 深浅拷贝.md) ⭐⭐

> 深拷贝和浅拷贝的区别？如何实现 
>
> 对于浅拷贝而言，假如有这样一个对象，该对象中有一部分属性是原始数据类型，也有一部分属性是引用数据类型。浅拷贝只能成功拷贝原始数据类型的数据，而对于引用类型的数据，拷贝的则是地址。也就是说，浅拷贝后的新对象中的引用数据类型的属性与原对象中的该属性共享同一块内存空间。
>
> 在我们的日常开发中，实际上很多api都仅仅实现的是一个浅拷贝，比如：
>
> [Object.assign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)方法，该方法用于混合对象，我们把第一个参数配置为一个空对象，第二个参数配置为被拷贝的对象，则该方法返回的是一个浅拷贝的新对象
>
> 另外，如果我们使用ES6的扩展运算符，将一个对象在一个空对象中展开，最终形成的对象实际上也是一个浅拷贝的新对象 
>
> 对于数组而言，数组的[concat](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)方法，该方法用于连接数组。如果我们不传递参数，则返回的是一个浅拷贝后的新数组。另外，数组的[slice](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)方法，该方法用于切割数组，如果我们不传递起始的索引值，那么返回的则是一个浅拷贝后的新数组。
>
> jQuery中的[$.extend(deep,target,object1,objectN)](https://jquery.cuishifeng.cn/jQuery.extend.html)方法，该方法用于混合对象。其中，该方法的第一个参数为一个布尔值，默认为fasle，表示浅拷贝
>
> lodash中的 [_.clone(value)`](https://www.lodashjs.com/docs/lodash.clone)方法，该方法接收一个参数为被拷贝的对象，返回一个浅拷贝后的新对象
>
> 对于深拷贝而言，假如有这样一个对象，该对象中有一部分属性是原始数据类型，也有一部分属性是引用数据类型。然而，深拷贝不仅能成功拷贝原始数据类型的数据，而且能够成功拷贝引用数据类型的数据。相当于是进行了递归的浅拷贝，深拷贝后的新对象中无论是原始数据类型的属性，还是引用数据类型的属性都与原对象中的对应属性完全隔离，各自享有自己的一块内存空间。
>
> 在我们的日常开发中，要实现深拷贝，有以下几种方式：
>
> 首先，我们可以利用`JSON.parse(JSON.stringify)`的方式，实现一个深拷贝。相当于我们先把一个对象转换成一个字符串，再将该字符串重新转换成一个新对象，从而实现了一个对象的深拷贝。但是，由于JSON的这类方法，本意是用于处理json数据的，而 JSON字符串是不能够接受函数的。因此，使用这种方式实现的深拷贝，会导致对象中的方法丢失了。
>
> 另外，之前说到的jQuery中的[$.extend(deep,target,object1,objectN)](https://jquery.cuishifeng.cn/jQuery.extend.html)方法，我们将该方法的第一参数配置为true，则表示深拷贝
>
> 然后，还有lodash中的[__.cloneDeep_](https://www.lodashjs.com/docs/lodash.cloneDeep)方法，该方法接收一个参数为被拷贝的对象，返回一个深拷贝后的新对象
>
> 如果，我们不想使用第三方库的话，就只能自己手写递归实现深拷贝了。这里，我就说一下[手写递归实现深拷贝](E:\help file\xgglt\JS\tools\深拷贝.md)的核心思路吧。……



### new 发生了什么？

> `new `关键字会进行如下的操作：
>
> 1. 创建一个空的JavaScript对象（即`{}`）
> 2. 为 步骤1 新创建的对象添加属性`__proto__`，将该属性链接至构造函数的原型对象
> 3. 将 步骤1 新创建的对象作为this的上下文
> 4. 如果该函数没有返回对象，则返回this

## Css

### [02 居中方式总结](E:\help file\xgglt\笔面试\CSS\02 居中方式总结.md) ⭐⭐

> 怎么让一个 *div* 水平垂直居中?
>
> 1. 弹性盒。将div的父元素设置为弹性盒，设置
>
>    ```css
>    display: flex;
>    justify-content: center;
>    align-items: center;
>    ```
>
> 2. 绝对定位。
>
> - 绝对定位配合margin-left,margin-top实现，设置（同时需要设置div父元素为相对定位`position:relative`）
>
>   ```css
>   position: absolute;
>   left: 50%;
>   top: 50%;
>   margin-left: div自身宽度的一半;
>   margin-top: div自身高度的一半;
>   ```
>
> - 绝对定位配合transform实现，设置（同时需要设置div父元素为相对定位`position:relative`）
>
>   ```css
>   position: absolute;
>   left: 50%;
>   top: 50%;
>   transform: translate(-50%,-50%);
>   ```
>
> 3. vertical-align：middle配合margin：0 auto实现
>
>    注意：
>
> - 使用 *vertical-align:middle* 的时候需要一个兄弟元素做参照物，我们通常给div的父元素添加一个伪元素作为兄弟元素。*vertical-align* 对齐的方法默认是寻找兄弟元素中最高的元素作为参照物。
>
> - *vertical* 生效的前提是元素的 `display：inline-block`(兄弟元素也需要设置该属性)

### 03 隐藏元素方式总结

> 隐藏页面中的某个元素的方法有哪些？
>
> 我们隐藏元素可以分为 3 大类：
> 1. 完全隐藏：元素从渲染树中消失，不占据空间。
> - display 属性。设置display为none
> - hidden属性。 *HTML5* 新增的hidden属性（布尔属性），设置到html标签上
> 2. 视觉上隐藏：页面中不可见，但仍然占据空间
> - opacity属性 设置`opacity：0`
> - *visibility* 属性 设置`visibility:hidden`
> - 绝对定位，设置top，left，将元素移出可视区域
> - 设置margin 将元素移出可视区域
> - 裁剪元素。使用css3的clip-path属性
> 3. 语义上隐藏：读屏软件不可读，但正常占据空间并可见。
> - 给html标签设置aria-hidden属性（布尔属性）

### 04 浮动

> 谈谈浮动。
>
> 浮动最初是为了实现“文字环绕”的效果。但在c3出来之前，我们是并没有弹性盒布局、网格布局等概念的。于是，开发者们只能使用浮动来进行布局。例如，利用浮动实现两栏布局、三栏布局等。
>
> 浮动的特性：
> - 脱离标准流（浮动元素会盖在普通元素之上，导致父元素高度坍塌）
> - 浮动元素相互贴靠，且宽度不够会自动排到下一行
> - 宽度收缩（浮动的块元素的宽度变成了宽度撑开容器大小）
> - 浮动元素 display属性会变为block
>
> 清除浮动：
> - 手动给父元素设置高度（注意：给父元素设置高度时，这个高度值一定要大于浮动子元素的高度）
> - clear属性 （弊端：导致*margin* 属性失效）
> - 内墙法、外墙法（通过添加空div配合clear属性清除浮动）
> - 伪元素清除法（利用伪元素实现内墙法，避免了添加多余的空div）
> - bfc （将父元素变成一个bfc，清除浮动）

### 05 定位总结

> 谈谈position定位。
>
> 1. *static* 静态定位（默认值）
> 2. *relative* 相对定位
> - 不脱离标准流
> - 相对于自己原来的位置上进行一定的偏移
> 3. *absolute* 绝对定位
> - 相对于离自己最近的且定位的祖先元素进行定位
> - 脱离标准流
> -*margin* 失效
> - 绝对定位后的盒子，其 *display* 属性会变为 *block*
> - **默认情况下，绝对定位的参考点：top（==页面的左上角==），bottom（==浏览器首屏窗口左下角==）**
> 4. *fixed* 固定定位
> - 脱离标准流
> - 相对于浏览器窗口进行定位
> 5. *sticky* 粘性定位
> - 元素在跨越特定阈值前是正常排列，之后为固定定位

### 06 BFC ⭐

> 谈谈BFC。
>
> 首先，BFC是Block formatting context的缩写，即块级格式化上下文。*BFC* 是一个独立的布局环境，*BFC* 内部的元素布局与外部互不影响。
>
> 创建BFC的方式：
> - 根元素（<html>）是一个天然的BFC
> - 设置浮动（float 值不为 none） 
> - 设置绝对定位或固定定位（position 值为 absolute 或 fixed）
> - 设置行内块元素（display 值为 inline-block）
> - 设置overflow（值不为 visible、clip 的块元素）
> [更多方式](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)
>
> BFC的应用场景
> 1. 解决浮动元素导致父元素高度坍塌的问题（将父元素设置成一个 *BFC*）
> 2. 避免非浮动元素被浮动元素覆盖（将被浮动元素覆盖的元素设置为BFC）
> 3. 解决外边距垂直方向合并的问题（任意为一个元素添加一个父元素，并将其设置为BFC）

### 07-08 CSS属性值的计算过程

> 谈谈CSS属性值的计算过程。
>
> 1. 确定声明值。参考样式表（作者样式表、浏览器默认样式表）中没有冲突的声明，作为CSS属性值。
> 2. 层叠冲突。对样式表（作者样式表、浏览器默认样式表）有冲突的声明使用层叠规则，确定CSS属性值
> - 比较重要性。作者样式表样式覆盖浏览器默认样式表样式。
> - 比较特殊性。即比较权重。
>    - 元素选择器和伪元素权重为1
>    - 类选择器、属性选择器、伪类权重为10
>    - ID选择器权重为100
>    - 行内样式权重为1000
> - 比较源次序（专用性）。后来的样式覆盖之前的样式。
> 3. 使用继承。对仍然没有值的属性，若可以继承，则继承父元素的值
> 4. 使用默认值。对仍然没有值的属性，使用默认值。

### 10 CSS3的calc函数

> 谈谈css的计算属性。
>
> css的计算属性即*CSS3* 中的 *calc* 函数。calc()函数允许在声明 CSS 属性值时执行一些计算。主要用于计算元素的尺寸，支持所有 *CSS* 长度单位。
>
> +和 - 运算符的两边必须要有空白字符。* 和 / 这两个运算符前后不需要空白字符，但如果考虑到统一性，仍然推荐加上空白符。

## Vue

### [01 组件通信总结](E:\help file\xgglt\笔面试\Vue\01 组件通信总结.md) ⭐⭐⭐

> vue组件之间有哪些通信方式？
>
> 我所了解到的vue组件之间的通信方式，大体上分为两类。一类是父子组件之间的通信，一类是跨组件之间的通信。
>
> 我先说一下父子组件之间的通信方式吧。首先，vue本身所提供的通信方式，大部分都是父子组件之间的通信方式。
>
> 比如，`prop`，父组件向子组件传递一个属性
>
> `event`,子组件发生了某些事情，需要通知父组件进行处理
>
> `style和class`，这种通信方式的通信范围比较窄，只能传递一些样式，父组件向子组件传递的style和class，会合并到子组件的根元素中
>
> `attribute`，attribute通常是指父组件向子组件传递了一些属性，但是子组件并没有声明这些属性，那么我们把这一类属性称之为attribute，attribute会附着在子组件的根元素上。同时，我们可以在子组件中通过`$attrs`进行获取。如果我们不想attribute附着在子组件的根元素上的话，可以在子组件中配置inheritAttrs属性，配置为false。这样一来attribute就不会附着在子组件的根元素上，但是仍然可以通过`$attrs`进行获取。
>
> `native`修饰符，父组件可以通过native修饰符，将事件注册到子组件的根元素上
>
> `$listeners`，子组件可以通过$listeners获取父组件传递过来的所有事件处理函数
>
> v-model，通过双向绑定一个数据实现父子组件之间的通信 
>
> `sync`修饰符， 和v-model的作用类似，也是通过双向绑定一个数据实现父子组件之间的通信。不同点在于v-model只能针对一个数据进行双向绑定，而sync修饰符则没有限制。
>
> `$parent`和`$children`，在组件内部，可以通过`$parent`和`$children`，分别获取当前组件的父组件实例和子组件实例
>
> `$slots`和`$scopedSlots` 插槽和作用域插槽。可以在插槽处传递一些元素或者是数据从而实现父子组件之间的通信
>
> ref，父组件可以通过`ref`获取到子组件的实例
>
> 以上就是我所了解到的父子组件之间的通信方式
>
> 而对于跨组件之间的通信方式而言呢，首先是
>
> `Provide`和`Inject`，祖先组件通过Provide提供数据，后代组件通过Inject注入数据，从而实现了跨组件之间的通信
>
> vue-router，通过改变地址栏，而间接的导致了那些监听地址栏变化的组件重新渲染，从而实现了跨组件之间的通信。
>
> `vuex`，数据仓库，一般适用于大型项目，中小型项目使用起来显得略微笨重。通过数据仓库从而实现跨组件之间的通信。
>
> store模式。自己手写一个store模块，实现数据共享。从而实现一个跨组件之间的通信
>
> `eventbus`，事件总线，通过在事件总线上触发事件和监听事件，从而实现了跨组件之间的通信方式。

### [02 虚拟dom详解](E:\help file\xgglt\笔面试\Vue\02 虚拟DOM详解.md) ⭐
> 请你阐述一下对vue虚拟dom的理解。
>
> **什么是虚拟dom：** 虚拟 DOM 最初是由 React 团队所提出的概念，是一种编程的思想，其核心在于对真实dom的描述。而在Vue中，虚拟dom的具体实现就是一个普通的JS对象，它用于描述视图的界面结构。
>
> 然后，我再说一下虚拟dom和组件之间的关系吧。在vue中，每个组件都有一个`render`函数，每个`render`函数会返回一棵虚拟dom树，这也就意味着每个组件都对应着自己的一棵虚拟DOM树。
>
> **为什么需要虚拟dom：**然后，我再说一下为什么需要虚拟dom吧。因为在`vue`中，渲染视图会调用`render`函数，这种渲染不仅发生在组件首次被创建时，同时发生在视图所依赖的响应式数据更新时。如果我们在渲染时，直接使用真实`DOM`的话，由于真实`DOM`的创建、更新、插入、删除等操作会带来大量的性能损耗（比如重排、重绘等），从而就会极大的降低渲染效率。因此，`vue`在渲染时，使用虚拟dom来替代真实dom，主要是为了解决渲染效率的问题。
>
> **虚拟dom是如何转换为真实dom：**最后，我说一下虚拟dom是如何转换为真实dom的。当一个组件首次被渲染时，会调用该组件的render函数，render函数会返回一棵虚拟dom树，然后根据虚拟dom树递归创建对应的真实dom，并把真实dom挂载到页面中合适的位置。(虚拟dom的elm属性对应则是真实dom`this._Vnode.elm`)其实，如果我们只关注首次渲染的性能的话，我们会发现使用虚拟dom的性能比直接创建真实dom的性能更差，因为它比直接创建真实dom多出了创建虚拟dom的过程，然而在更新页面时虚拟dom的作用才真正的体现出来。如果一个组件受响应式数据变化的影响，需要重新渲染时，它仍然会重新调用render函数，创建出一棵新的虚拟dom树，用新的虚拟dom树和旧的虚拟dom树进行对比，通过对比，vue会找到最小更新量，然后更新它们对应的真实dom。这样一来，就保证了对真实dom达到最小的改动。
>
> 最后，我说一下模板和虚拟dom的关系吧。vue框架中有一个`compile`模块，它负责将模板编译为render函数。编译的过程分为两步：1.将模板字符串转换成为`AST`(抽象语法树)（用一种JS的树形结构来描述我们的JS代码）2.将`AST`转换为`render`函数。然而，render函数调用后将得到虚拟dom。因此，模板中的各种语法，最终都变成了虚拟dom的配置。

### [03 v-model](E:\help file\xgglt\笔面试\Vue\03 v-model.md)

> 面试题：请阐述一下 `v-model` 的原理
>
> `v-model`既可以作用于表单元素，又可以作用于自定义组件，但无论是哪一种情况，它都只是一个语法糖，最终会生成一个属性和一个事件。
>
> 当v-model作用于表单元素时，`vue`会根据表单元素的类型而生成对应的属性和事件。比如，当v-model作用于普通文本框的时候，它会生成`value`属性和`input`事件，当v-model作用于单选框或多选框时，它会生成`checked`属性和`change`事件。
>
>
> 当v-model作用于自定义组件时，默认情况下，它会生成一个`value`属性和`input`事件。但是，开发者可以通过组件的`model`配置来改变生成的属性名和事件名

### [04 数据响应式原理](E:\help file\xgglt\笔面试\Vue\04 数据响应式原理.md) ⭐⭐

> 面试题：请阐述`vue2`响应式原理
>
> 对于（数据）响应式，在我们日常开发过程中，最直观的感受，无非是数据变化之后会自动更新视图。这也是vue的设计理念之一，vue希望我们将开发的侧重点放在操作数据上，而不再是直接操作dom元素。 
>
> 在vue中，（数据）响应式，无非就是当对象本身或对象属性发生变化时，vue会运行一些函数。其中，最常见的就是render函数。在在具体实现上，vue用到了4个核心部件，分别是**Observer、Dep、Watcher、Scheduler**。
>
> **Observer**：Observer要实现的目标非常简单，就是把一个普通对象转换为一个响应式对象。为了实现这一点，Observer会递归遍历对象的所有属性，把对象的每个属性通过`Object.defineProperty`转换为带有 `getter `和 `setter `的属性，这样一来，当读取或设置属性值时，vue 就有机会做一些别的事情。但是，由于遍历时只能遍历到对象当前的属性，因此无法监测到将来动态增加或删除的属性，所以vue提供了`$set`和`$delete`两个实例方法，供开发者对已有的响应式对象添加或删除属性。然而，对于数组，vue会更改它的隐式原型为vue自定义的一个对象，之所以这样做，是因为vue需要监听那些可能改变数组内容的方法。同时，为了让数组仍然可以使用数组原有的实例方法，vue又将自定义的对象的隐式原型指向了Array.prototype。总之，Observer的最终目标，就是要让对象的属性的读取、赋值和内部数组的变化都要能够被vue所感知到。
>
> **Dep**：Observer有两个问题没解决，就是读取属性时要做什么事，而属性变化时又要做什么事，这个两个问题需要依靠Dep来解决。`Vue`会为响应式对象中的每个属性、对象本身、数组本身分别创建一个`Dep`实例，每个`Dep`实例都有能力做两件事：1.`dep.depend()`收集依赖：表示是谁在用我 2.`dep.notify()`派发更新：表示我变了，我要通知那些用到我的人。在vue中，当读取响应式对象的某个属性时，`dep`会进行依赖收集；当改变响应式对象的某个属性时，`dep`会派发更新。
>
> **Watcher**：Dep也有一个问题没有解决，就是Dep如何知道是谁在用我。要解决这个问题，需要依靠另一个东西，就是Watcher。在某个函数执行的过程中，如果用到了响应式数据，响应式数据是无法知道是哪个函数在使用自己的。因此，我们不能直接执行函数，而是把函数交给watcher去执行。每个用到了响应式数据的函数都应该创建一个watcher，并通过watcher去执行。watcher会设置一个全局变量，让全局变量记录当前负责执行的watcher等于自己，然后再去执行函数，在函数的执行过程中，如果发生了依赖收集，那么`Dep`就会把这个全局变量记录下来，表示：有一个watcher用到了我这个属性。将来当属性变化时，就会派发更新，通知之前记录的所有watcher我变了。在vue中，每一个`vue`组件实例，都至少对应一个`watcher`，该`watcher`中记录了该组件的`render`函数。`watcher`首先会把`render`函数运行一次以收集依赖，于是render函数中所用到的响应式数据就会记录这个watcher。之后，当响应式数据变化时，dep就会通知该watcher，watcher就会重新运行render函数，从而让界面重新渲染同时重新记录当前的依赖。
>
> **Scheduler**：现在还剩下最后一个问题，就是Dep通知watcher之后，如果同一个watcher反复执行，就会导致对应的函数频繁运行，从而导致效率低下。比方说，如果同一个组件中，不同的响应式数据连续变化，那么就会多次调用render函数从而触发多次更新，这样显然是不合适的。因此，watcher收到派发更新的通知后，实际上不是立即执行对应函数，而是把自己交给一个叫``Scheduler`调度器的东西。调度器会维护一个执行队列，该队列同一个watcher仅会存在一次，队列中的watcher不会立即执行，它会通过一个叫做`nextTick`的工具方法，把这些需要执行的watcher放入到事件循环的微队列中。也就是说，在vue中，当响应式数据变化时，`render`函数的执行是异步的，并且在微队列中。

### [05 diff](E:\help file\xgglt\笔面试\Vue\05 diff.md) ⭐

> 请阐述vue的diff算法
>
> 在vue中，当组件创建和更新时，vue均会运行内部的`_update`函数，该函数接收`_render`函数返回的虚拟dom树的根节点作为参数，将新旧两树进行对比，找到最小更新量，最终更新到真实dom
>
> `diff`就发生在`_update`函数的运行过程中，其中对比差异的过程叫diff， vue 内部通过一个叫 patch 的函数完成该过程。
>
> 在对比时， vue 采用深度优先、同层比较的方式进行比对。
>
> 另外，在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的，如果是`input`元素还要额外看`type`属性。
>
> patch函数的流程，具体来说，会首先对新旧两树的根节点进行对比，如果不相同，则按照新树的节点信息递归创建所有真实dom，同时将真实dom挂到对应虚拟节点的`elm` 属性上，然后移除掉旧的真实dom；如果相同，则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；
>
> 在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的更新流程；如果发现不同，则优先考虑能否移动真实dom来实现复用真实dom的目的，实在不行再去删除和创建元素。

### [06 生命周期详解](E:\help file\xgglt\笔面试\Vue\06 生命周期详解.md) ⭐⭐⭐

> 面试题：`new Vue`之后，发生了什么？数据改变后，又发生了什么？（创建vue实例和创建组件的流程）
>
> **首次创建：**
>
> 1. 首先，会做一些初始化的配置，主要是设置一些私有属性到实例中，比如一些以`$`开头或者`_`开头的属性。
> 2. **运行生命周期钩子函数`beforeCreate`**
> 3. 完成数据响应式，进入注入流程。也就是将 props、data、computed、methods、provide、inject 等组件配置，注入到组件实例中。
> 4. **运行生命周期钩子函数`created`**
> 5. 生成`render`函数：如果配置了render函数，则直接使用配置的render函数，如果没有，会将模板编译为render函数
> 6. **运行生命周期钩子函数`beforeMount`**
> 7. 创建一个`Watcher`，并传入`updateComponent`函数，该函数会运行`_render`函数，再将_render函数返回的虚拟dom树的根节点作为参数传入`_update`函数执行。
> - 在执行`render`函数的过程中，所使用到的响应式数据会进行依赖收集，记录当前的`Watcher`，将来响应式数据变化时会派发更新，即会通知记录的`Watcher`重新运行`updateComponent`函数
> - 在执行`_update`函数的过程中，触发内部的`patch`函数，由于是首次创建没有旧的虚拟dom树，因此直接根据当前的虚拟dom树递归创建对应的真实dom，并挂载到页面中合适的位置。
> 8. **运行生命周期钩子函数`mounted`**
>
> **重渲染：**
>
> 1. **运行生命周期钩子函数`beforeUpdate`**
>
> 2. 派发更新，通知记录的`Watcher`重新运行`updateComponent`函数。此时，`Watcher`会被``Scheduler`调度器通过 nextTick 工具方法放入到事件循环的微队列中。微队列中的`Watcher`逐一运行，则`updateComponent`函数重新执行。
>
>       在`updateComponent`函数运行的过程中，_render 函数重新运行，重新收集新的依赖，并生成新的虚拟dom树。将新生成的虚拟dom树的根节点作为参数传入`_update`函数，从而触发patch函数开始 diff 对比更新过程。
>
>    在diff的过程中：如果有新组件需要创建时，则进入首次创建流程。如果有旧组件需要删除时，会调用旧组件的`$destroy`方法删除组件，该方法会先触发**生命周期钩子函数`beforeDestroy`**，然后递归调用子组件的`$destroy`方法，最后触发**生命周期钩子函数`destroyed`**
>3. **当一切都更新完毕后，运行生命周期钩子函数`updated`**

### [07 你不知道的computed](E:\help file\xgglt\笔面试\Vue\07 你不知道的computed.md)

> 面试题：computed和methods有什么区别
>
> **使用层面：**首先，我先说一下在日常开发过程中，computed和methods在使用层面的区别吧。
>
> 1. 在使用时，computed当做属性使用，而methods则当做方法调用
> 2. computed可以具有getter和setter，因此可以赋值，而methods不行
> 3. computed无法接收多个参数，而methods可以
> 4. computed具有缓存，而methods没有
>
> **原理层面:**
>
> 在vue中，对methods的处理比较简单，只需要遍历methods配置中的每个属性，将其对应的函数使用bind绑定当前组件实例后复制其引用到组件实例中即可
>
> 然而，对computed的处理会稍微复杂一些。
>
> 在生命周期钩子函数`beforeCreate`运行后，会做一系列事情，其中就包括对computed的处理
>
> Vue 会遍历 computed 配置中的每个属性，为每个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是computed配置中的get函数，这样一来，get函数运行过程中就会收集依赖，记录当前 watcher
>
> 但是和 render 函数不同，为计算属性创建的 Watcher 并不会立即执行，因为要考虑到该计算属性是否会被 render 函数所使用，如果没有使用，就不会得到执行。因此，在为计算属性创建 Watcher 的时候，内部使用了`lazy`配置，`lazy`配置可以让 Watcher 不会立即执行。
>
> 受到`lazy`配置的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是`value`，一个是`dirty`
>
> `value`属性用于保存 Watcher 运行的结果，受`lazy`的影响，该值在最开始是`undefined`
>
> `dirty`属性用于指示当前的`value`是否已经过时了，受`lazy`的影响，该值在最开始是`true`
>
> Watcher 创建好后，vue 将计算属性注入到组件实例中
>
> 当读取计算属性时，vue 检查其对应的Watcher中的 dirty 属性，检查是否是脏值，如果是，则运行函数收集依赖，得到计算属性对应的值，保存在Watcher的value属性中，然后设置dirty属性为false，然后返回计算属性对应的值。
>
> 如果 dirty 属性为 false ，则直接返回 watcher 的 value 属性值
>
> 巧妙的是，在依赖收集时，计算属性不仅会收集到计算属性的 Watcher ，还会收集到组件的Watcher
>
> 当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置`dirty`为true即可，其他不做任何处理。
>
> 由于计算属性同时收集到了组件的Watcher，因此组件会重新渲染，重新渲染时又读取到了计算属性，由于计算属性目前的dirty已经为true，因此会重新运行get函数进行运算
>
> 而对于计算属性的setter，则极其简单，当设置计算属性时，直接运行set函数即可
