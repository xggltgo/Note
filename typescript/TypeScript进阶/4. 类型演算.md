# 类型演算



## 三个关键字

### typeof

在TS中，typeof书写在类型约束位置处，表示**获取某个数据的类型**

```typescript
const a: string = '123';
const b: typeof a = '456'; // 获取变量a的类型，则b的类型被限制为string
```

当 typeof 作用于类的时候，得到的类型，是该类本身（构造函数）

`const a:类名`：以这种方式修饰 a ，表示的是a是类的实例对象，而不是类本身：

```typescript
class User {
  name: string;
  age: number;
}

// 该函数用于初始化一个类，参数为类本身
function initClass(cls: User) {
  return new User();
}

initClass(User); // TS错误提示：类型“typeof User”的参数不能赋给类型“User”的参数。
```

正确代码为：`const a:typeof 类名`

```typescript
class User {
  name: string;
  age: number;
}

// 该函数用于初始化一个类，参数为类本身
function initClass(cls: typeof User) {
  return new User();
}

initClass(User); 
```

### keyof

> keyof 用于获取类型别名、接口、类中的所有成员名组成的联合类型

**原始代码：**

```typescript
interface User {
  name: string;
  age: number;
}

function getVal(obj: User, prop: 'name' | 'age') {
  return obj[prop];
}
```

**添加 keyof 后的代码**

```typescript
interface User {
  name: string;
  age: number;
}

function getVal(obj: User, prop: keyof User) { // 此处代码与原始代码等效，但优势在于如果后期我们动态的给User添加了成员，由于keyof是动态读取的，因此此处并不需要修改代码
  return obj[prop];
}
```

### in

> in 关键字往往和keyof一起使用，用于限制某个索引类型的取值范围

```typescript
interface User {
  name: string;
  age: number;
}
```

书写一个新类型：将接口User所有的属性值类型变成 string

```typescript
interface User {
  name: string;
  age: number;
}

// 等效代码1：
// type UserToString = {
//   name: string;
//   age: string;
// };

// 等效代码2：
// type UserToString = {
//   [p in 'name' | 'age']: string;
// };

//等效代码3：
type UserToString = {
  [p in keyof User]: string;
};

const u: UserToString = {
  name: 'kb',
  age: '30',
};
```

书写一个新类型：要求与接口User完全保持一致

```typescript
interface User {
  name: string;
  age: number;
}

type CopyUser = {
  [p in keyof User]: User[p]; //此处可以通过 User[p]动态读出User属性值对应的类型
};

const u: CopyUser = {
  name: 'kb',
  age: 35,
};
```

书写一个新类型：要求与接口User完全保持一致，但是是User的成员都是只读的

```typescript
interface User {
  name: string;
  age: number;
}

type ReadonlyUser = {
  readonly [p in keyof User]: User[p]; 
};

const u: ReadonlyUser = {
  name: 'kb',
  age: 35,
};

u.age = 20; // ts错误提示：无法为“age”赋值，因为它是只读属性。
```

**利用泛型，抽离将原有类型变为只读**

```typescript
interface User {
  name: string;
  age: number;
}

interface Book {
  name: string;
  pulishDate?: Date;
}

type ReadOnly<T> = {
  readonly [p in keyof T]: T[p];
};

const u: ReadOnly<User> = {
  name: 'kb',
  age: 35,
};

u.age = 20; // ts错误提示：无法为“age”赋值，因为它是只读属性。

const b: ReadOnly<Book> = {
  name: '钢铁是怎么练成的',
};

b.name = 'no' // ts错误提示：无法为“name”赋值，因为它是只读属性。
```



## 预定义的类型演算

TS中预设的类型演算：

| 代码            | 含义                                   |
| --------------- | -------------------------------------- |
| Partial<T>      | 将类型T中的所有成员变成可选            |
| Required<T>     | 将类型T中的所有成员变成必填            |
| Readonly<T>     | 将类型T中的所有成员变成只读            |
| Exclude<T,U>    | 从T中移除U中的类型，T和U通常是联合类型 |
| Extract<T,U>    | 获取T、U的交集部分，T和U通常是联合类型 |
| NonNullable<T>  | 从T中移除null和undefined               |
| ReturnType<T>   | 获取函数类型T的返回值类型              |
| InstanceType<T> | 获取构造函数类型T的实例类型            |

