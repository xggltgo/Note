# 泛型

> 泛型：附属在函数、类、接口、类型别名之上的类型
>
> 定义泛型：书写在（函数、类、接口、类型别名）名称之后<泛型名称>

1. 在定义（函数、类、接口、类型别名）时，泛型相当于是一个**类型变量**；在调用时书写的具体类型，会赋值给对应的类型变量。
2. 多数情况下，TS能够根据开发者书写的字面量，智能的推导出泛型的具体类型；如果无法完成类型推导，默认为空对象类型
3. 泛型可以设置默认值：`<泛型名称 = 默认值>`
4. 泛型可以继承（泛型约束）：`<泛型名称 extends xxx>`



## 函数中使用泛型

在某些场景下，封装某个函数时，函数中存在多个位置的类型应该保持一致或保持关联。

```typescript
/**
 * 取出指定数组的前n个元素，组成一个新数组返回（函数参数、内部数组、函数返回值应该为同一类型的数组）
 * @param arr 数组
 * @param n 个数
 */

//不使用泛型的处理方式：
function take(arr: any[], n: number): any[] {
  if (n >= arr.length) {
    return [...arr];
  }
  const newArr: any[] = [];
  for (let i = 0; i < n; i++) {
    newArr.push(arr[i]);
  }
  return newArr;
}
console.log(take([1,2,3,4,5],3)); //[1,2,3]

//使用泛型的处理方式
function take<T>(arr: T[], n: number): T[] {
  if (n >= arr.length) {
    return [...arr];
  }
  const newArr: T[] = [];
  for (let i = 0; i < n; i++) {
    newArr.push(arr[i]);
  }
  return newArr;
}
console.log(take<number>([1, 2, 3, 4, 5], 3)); //[1,2,3]
console.log(take<string>(['a', 'b', 'c', 'd', 'e'], 3)); //[ 'a', 'b', 'c' ]
console.log(take([true,false,true,false,true], 3)); //[ true, false, true ] //此处，TS能够根据传递的参数智能的推导出泛型的具体类型
```



## 类、接口、类型别名中使用泛型

在类型别名、接口中使用泛型：

```typescript
// 传递回调函数， 判断数组的某一项是否满足条件，此处item可以是任何类型，因此需要使用泛型
// type callback<T> = (item: T, index: number) => boolean;
interface callback<T> {
  (item: T, index: number): boolean;
} 

function filter<T>(arr: T[], callback: callback<T>): T[] {
  const newArr: T[] = [];
  arr.forEach((item, index) => {
    if (callback(item, index)) {
      newArr.push(item);
    }
  }); 
  return newArr;
}

const result = filter([1, 2, 3, 4, 5], (n) => n % 2 === 0);
console.log(result); // [2,4]
```

在类中书写泛型： 

```typescript
// 书写一个数组帮助类
export class ArrayHelper<T> {
  constructor(private arr: T[]) {}

  //取出数组中前n项元素（实例方法）
  take(n: number): T[] {
    if (n >= this.arr.length) {
      return [...this.arr];
    } else {
      const newArr: T[] = [];
      for (let i = 0; i < n; i++) {
        newArr.push(this.arr[i]);
      }
      return newArr;
    }
  }
  
}
```



## 泛型约束

> 我们试图编写一个用于对身份证号进行加密的函数，即仅显示身份证号后四位，其余使用‘*’代替。

 ```typescript
 function encryption<T>(person:T){   
 }
 ```

遇到的问题：

1. 我们希望该函数的参数仅接收对象作为参数，若参数传递为其他类型我们希望TS会报错
2. 该参数所接收的对象必须包含一个`idcard`属性，表示身份证号

**此时我们则需要使用泛型约束**

```typescript
interface PersonWithIdcard {
  idcard: string;
}
//让泛型继承自接口，以进一步限定参数的类型
function encryption<T extends PersonWithIdcard>(person: T): T {
  person.idcard = person.idcard
    .split('')
    .map((item, index, array) => {
      if (index <= array.length - 5) {
        return '*';
      } else {
        return item;
      }
    })
    .join('');
  return person;
}

const person = {
  name: 'xgglt',
  idcard: '0127021',
};

const idcard = encryption(person);
console.log(idcard); //{ name: 'xgglt', idcard: '***7021' }
```



## 多泛型

> 在某些特定场景下，可能需要书写多个泛型来进行控制

```typescript
//连接两个数组，返回一个新数组
function concat<T, K>(arr1: T[], arr2: K[]): (T | K)[] {
  const newArr: (T | K)[] = [];
  for (let i = 0; i < arr1.length; i++) {
    newArr.push(arr1[i]);
  }
  for (let i = 0; i < arr2.length; i++) {
    newArr.push(arr2[i]);
  }
  return newArr;
}

const newArr = concat([1, 2, 3], ['a', 'b', 'c']);
console.log(newArr); // [ 1, 2, 3, 'a', 'b', 'c' ]
```

