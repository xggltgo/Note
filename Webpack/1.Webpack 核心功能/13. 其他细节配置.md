# 其他细节配置

## context

```js
context: path.resolve(__dirname, "src")
```

该配置会影响入口和loaders的解析，入口和loaders的相对路径会以context的配置作为基准路径，我们通常利用path模块将其配置为一个绝对路径

这样，你的配置会独立于CWD（curr ent working directory 当前执行路径[命令行路径]），不配置 context ，入口和loaders的相对路径默认相对于CWD

## output

### library

```js
library: "abc"
```

这样一来，会将打包结果中的自执行函数的返回值暴露给abc：

```js
var abc = (function (module){
  
})({ 
  // ...
})
```

作用：

1. 书写一个第三方库，暴露一个全局变量，供开发者使用 （参考：jquery）
2. 与某些plugin配合使用时，可能需要暴露一个全局变量

### libraryTarget

```js
library: "abc"
libraryTarget: "window"
```

该配置通常与`library`配置连用，可以更加精细的控制如何暴露入口包的导出结果

```js
window['abc'] = (function (module){
  
})({ 
  // ...
})
```

其他可用的值有：

- var：默认值，暴露给一个普通变量
- window：暴露给window对象的一个属性
- this：暴露给this的一个属性
- global：暴露给global的一个属性
- commonjs：暴露给exports的一个属性
- 其他：https://www.webpackjs.com/configuration/output/#output-librarytarget

## target

```js
target:"web" //默认值
```

配置打包结果最终要运行的环境，常用值有

- web: 打包后的代码运行在web（浏览器）环境中
- node：打包后的代码运行在node环境中
- 其他：https://www.webpackjs.com/configuration/target/

不同的配置，会影响webpack解析依赖的方式

## module.noParse

```js
noParse: /jquery/ //配置为正则表达式
```

如果某个模块匹配上 noParse 配置的规则，那么在 webpack 构建依赖模块的过程中，该模块会略过转换为AST、分析依赖生成dependences、替换依赖函数等步骤，而是将模块内容读取出来后直接存入最终的模块列表中。

不解析正则表达式匹配的模块，通常用它来忽略那些**大型**的**单模块库**，以提高**构建性能**

例如：jquery	

由于我们 npm i jquery 然后 require(‘jquery’)时，导入的jquery实际上是内部打包合并后的单个js文件，因此它并不会依赖其他模块，这时我们将配置 noParse: /jquery/ ，以让webpack不去解析它，以此提高构建性能（打包速度）

## resolve

resolve的相关配置主要用于控制模块解析过程

### modules

```js
modules: ["node_modules"]  //模块的查找位置 默认值node_modules
```

当解析模块时，如果遇到导入语句，```require("test")```，webpack会从下面的位置寻找依赖的模块

1.  当前目录下的```node_modules```目录
2. 上级目录下的```node_modules```目录
3. ...

### extensions

```js
extensions: [".js", ".json"]  //默认值
```

当解析模块时，遇到无具体后缀的导入语句，例如```require("test")```，会依次测试它的后缀名

- test.js
- test.json

### alias

```js
alias: {
  "@": path.resolve(__dirname, 'src'),
  "_": __dirname
}
```

有了alias（别名）后，导入语句中可以加入配置的键名，例如```require("@/abc.js")```，webpack会将其看作是```require(src的绝对路径+"/abc.js")```。

在大型系统中，源码结构往往比较深和复杂，别名配置可以让我们更加方便的导入依赖

## externals

```js
externals: {
    jquery: "$",
    lodash: "_"
}
```

从最终的bundle中排除掉配置的配置的源码，例如，入口模块是

```js
//index.js
require("jquery")
require("lodash")
```

生成的bundle是：

```js
(function(){
    ...
})({
    "./src/index.js": function(module, exports, __webpack_require__){
        __webpack_require__("jquery")
        __webpack_require__("lodash")
    },
    "jquery": function(module, exports){
        //jquery的大量源码
    },
    "lodash": function(module, exports){
        //lodash的大量源码
    },
})
```

但有了上面的配置后，则变成了

```js
(function(){
    ...
})({
    "./src/index.js": function(module, exports, __webpack_require__){
        __webpack_require__("jquery")
        __webpack_require__("lodash")
    },
    "jquery": function(module, exports){
        module.exports = $;
    },
    "lodash": function(module, exports){
        module.exports = _;
    },
})
```

这比较适用于一些第三方库来自于外部CDN的情况，这样一来，既可以在页面中使用CDN，又让bundle的体积变得更小，还不影响源码的编写

## stats

stats控制的是构建过程中控制台的输出内容

```js
stats:{
  colors:true,  //输出带颜色
  modules:false, // 不输出哪些模块被构建了
  hash:false, // 不输入hash
  builtAt:false //
}
```

## 思考

> webpack中书写了以下代码
>
> ```js
> var $ = require('jquery');
> ```
>
> 我们都知道，书写了上述代码后，会从当前文件夹依次向上查找node_modules目录，那么请问这个查找过程是谁在查找？
>
> A. node在查找jquery
>
> B. webpack在查找jquery
>
> 答案是B，因为在webpack打包过程中，并不会运行代码 