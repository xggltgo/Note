# 手写applyMiddleware

middleware的本质，是一个调用后可以得到dispatch创建函数的函数

compose：函数组合，将一个数组中的函数进行组合，形成一个新的函数，该函数调用时，实际上是反向调用之前组合的函数

## 封装 applyMiddleware

```js
import compose from './utils/compose';

/**
 * 返回一个函数
 * 该函数接收一个参数（创建仓库的方法） createStore函数
 * @param  {...any} Middlewares 传入的中间件
 */
export default function (...Middlewares) {
  return function (createStore) {
    //返回一个函数，该函数为仓库创建函数
    return function (reducer, defaultState) {
      //此函数用于返回一个中间件处理后的仓库
      const store = createStore(reducer, defaultState);

      let dispatch = () => {
        throw new Error('dispatch can not be called now');
      };

      //构造一个精简版的store 供中间件使用
      const simpleStore = {
        dispatch: (...args) => dispatch(...args), //此处应配置为一个函数，目的是拿到最终合成dispatch的引用
        getState: store.getState,
      };

      //处理传递的中间件
      const dispatchCreators = Middlewares.map(
        (
          middleware //拿到dispatch创建函数组成的数组，每个函数参数为dispatch函数
        ) => middleware(simpleStore)
      );

      //反向调用dispatch创建函数组成的数组，传入初始仓库中的dispatch函数，得到一个最终的dispatch函数返回
      dispatch = compose(...dispatchCreators)(store.dispatch);

      return {
        ...store,
        dispatch,
      };
    };
  };
}
```

## 核心封装 compose

```js
/**
 * 返回一个合成函数，该函数内部会根据传递的函数顺序，逆向调用每个函数
 * 并且，前一个函数的返回值作为后一个函数的参数
 * 例如：最后一个函数使用合成函数传递的参数，最先运行完成，并将最后一个函数的返回值，作为倒数第二个函数的参数，再运行倒数第二个函数
 * @param  {...any} func 函数作为参数，函数个数不限
 */
export default function compose(...funcs) {
  if (funcs.length === 0) {
    return (args) => args;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  //方式1
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
  
  //方式2
  //   return (...args) => {
  //     let prevResult = null;
  //     for (let i = funcs.length - 1; i >= 0; i--) {
  //       const func = funcs[i];
  //       if (i === funcs.length - 1) {
  //         prevResult = func(...args);
  //       } else {
  //         prevResult = func(prevResult);
  //       }
  //     }
  //     return prevResult;
  //   };
}
```

