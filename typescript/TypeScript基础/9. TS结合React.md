# TS+React

## 工程搭建

1.  webpack 手动搭建

2.  [create-react-app脚手架](https://github.com/facebook/create-react-app/blob/main/docusaurus/docs/adding-typescript.md) 快速搭建

   ```shell
   npx create-react-app my-app --template typescript
   ```

**初始工程的ts配置文件说明**

```json
{
  "compilerOptions": {
    "target": "es5", //配置编译结果代码所使用的版本标准
    "lib": ["dom", "dom.iterable", "esnext"], //1.'dom'：提供浏览器全局环境 2.'dom.iterable'：兼容低版本浏览器，由于低版本浏览器获取的dom元素（伪）数组不是迭代器，启用此配置后则低版本浏览器获取的dom元素（伪）数组是迭代器 3.'esnext':书写代码可使用的es版本
    "downlevelIteration": true, //若不启用此配置，则for-of循环仅能迭代数组和字符串；启用此配置后，只要满足可迭代协议就能被for-of循环迭代(此配置非初始工程默认配置，为后续手动添加的配置)
    "allowJs": true, //允许TS与JS交互（在ts文件中导入js文件使用）
    "skipLibCheck": true, //跳过对声明文件的类型检查
    "esModuleInterop": true, //启用es模块化与非es模块导出进行交互
    "allowSyntheticDefaultImports": true, //"esModuleInterop": true 启用后，此配置自动开启（这里可以不再配置）
    "strict": true, //全局严格检查 涵盖（"strictNullChecks": true,"strictPropertyInitialization": true）等功能
    "forceConsistentCasingInFileNames": true, //不允许不一致的大小写引用（导入文件时文件名区分大小写）
    "noFallthroughCasesInSwitch": true, //在switch语句中启用错误报告
    "module": "esnext", //配置编译结果代码所使用的模块化标准（'esnext'支持动态导入）
    "moduleResolution": "node", //配置解析模块的模式
    "resolveJsonModule": true, //解析JSON模块（导入json文件当作对象使用）
    "isolatedModules": true, //把每一个文件作为一个模块（包含导入导出语句）
    "noEmit": true, //不生成js文件
    "jsx": "react-jsx" //配置jsx代码编译后的输出形式
  },
  "include": ["src"] //配置需要编译(ts->js)的文件夹
}

```

核心流程：

![image-20221122222854412](9. TS结合React/image-20221122222854412.png)

## 具体用法 

### React+JS 遇到的问题

1. 导入外部组件使用时，没有组件属性提示，往往需要开发者到对应组件中查看需要传递的属性及属性需要传递的类型

2. 错误暴露的时间较晚直到运行时，不能在开发者书写代码时进行相应的错误提示



### React+TS 使用方式

#### 函数组件

书写函数组件，限定属性类型

*方式1：*

```tsx
export interface IProps {
  num: number;
  onChange?: (n: number) => void;
}

export function Count(props: IProps) {
  return (
    <div>
      <button onClick={() => { props.onChange && props.onChange(props.num - 1);}}> - </button>
      <span>{props.num}</span> 
      <button onClick={() => { props.onChange && props.onChange(props.num + 1);}}> + </button>
    </div>
  );
}
```

*方式2：*

```tsx
export interface IProps {
  num: number;
  onChange?: (n: number) => void;
} 

export const Count: React.FC<IProps> = (props) => {
  return (
    <div>
      <button onClick={() => { props.onChange && props.onChange(props.num - 1);}}> - </button>
      <span>{props.num}</span>
      <button onClick={() => { props.onChange && props.onChange(props.num + 1);}}> + </button>
    </div>
  );
};

Count.defaultProps = { //设置属性默认值，前提是需要将函数组件类型限定为React.FC
  num: 0,
};
```



#### 类组件

书写类组件，限定属性、状态类型

```tsx
import React from 'react';

export interface IProps {
  num: number;
  onChange?: (n: number) => void;
}  

interface IState {
  num: number;
  tips: string;
} 

export default class Count extends React.Component<IProps> { //此处泛型可以书写为<IProps,IState>

  state:IState = {
    num:10,
    tips:"this is a count", 
  };

  render() {
    return (
      <div>
        <button onClick={() => { this.props.onChange && this.props.onChange(this.props.num - 1);}}> - </button>
        <span>{this.props.num}</span>
        <button onClick={() => { this.props.onChange && this.props.onChange(this.props.num + 1);}}> + </button>
      </div>
    );
  }
}
```

**类组件细节：只有在`React.Component`后书写状态的泛型，`this.setState`函数才能获得对应的书写提示**

```tsx
import { Count } from './components/Count';

import { Component } from 'react';

interface IState {
  num: number;
}

export default class App extends Component<{}, IState> { //只有在`React.Component`后书写状态的泛型，`this.setState`函数才能获得对应的书写提示
  state = {
    num: 7,
  };

  render() {
    return (
      <Count
        num={this.state.num}
        onChange={(n) => {
          this.setState({
            num: n,
          });
        }}
      />
    );
  }
}
```







   

