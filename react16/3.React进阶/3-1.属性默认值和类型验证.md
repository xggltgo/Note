# 属性默认值 和 类型检查

> 属性默认值 和 类型检查 在封装通用组件时比较实用 便于其他开发者更加友好的复用组件

## 属性默认值

通过一个静态属性```defaultProps```告知react属性默认值

> 对于函数式组件，函数运行之前，已经完成了默认属性和属性的混合
>
> 对于类组件，在 `constructor`生命周期钩子函数之前，就已经完成了默认属性和属性的混合

### 函数组件

```jsx
export default function FuncComp(props) {
  return <div>FuncComp{props.desc}</div>;
}

FuncComp.defaultProps = {
  desc: '属性默认值',
};
```

### 类组件

```jsx
import { Component } from 'react';

export default class ClassComp extends Component {
  
  static defaultProps = {
    desc: '属性默认值',
  };

  render() {
    return (
      <div>ClassComp{this.props.desc}</div>
    );
  }
}
```



## 属性类型检查

使用库：```prop-types```

对组件使用静态属性```propTypes```告知react如何检查属性

注意顺序：先混合传递的属性和默认属性，再对属性进行验证，属性验证本质是调用 `prop-types` 中封装的函数

```js

PropTypes.any：//任意类型
PropTypes.array：//数组类型
PropTypes.bool：//布尔类型
PropTypes.func：//函数类型
PropTypes.number：//数字类型
PropTypes.object：//对象类型
PropTypes.string：//字符串类型
PropTypes.symbol：//符号类型

PropTypes.node：//任何可以被渲染的内容，字符串、数字、React元素
PropTypes.element：//react元素
PropTypes.elementType：//react元素类型
PropTypes.instanceOf(构造函数)：//必须是指定构造函数的实例
PropTypes.oneOf([xxx, xxx])：//枚举 PropTypes.oneOf(['男', '女']);
PropTypes.oneOfType([xxx, xxx]);  //属性类型必须是数组中的其中一个 
PropTypes.arrayOf(PropTypes.XXX)：//必须是某一类型组成的数组
PropTypes.objectOf(PropTypes.XXX)：//对象由某一类型的值组成
PropTypes.shape(对象): //属性必须是对象，并且满足指定的对象要求
PropTypes.exact({...})：//对象必须精确匹配传递的数据 比shape更严格 属性不能少传也不能多传

//自定义属性检查，如果有错误，返回错误对象即可
属性: function(props, propName, componentName) { //参数1：整个属性对象、参数2：属性名，参数3：组件名
   //...
}
```

### 函数组件

```jsx
import propTypes from 'prop-types';

export default function FuncComp(props) {
  return <div>FuncComp{props.count}</div>;
}

FuncComp.propTypes = {
  count: propTypes.number.isRequired,
};
```

### 类组件

```js
import React, { Component } from 'react'
import PropTypes from "prop-types";

export default class ValidationComp extends Component {
    //先混合属性
    static defaultProps = {
        b: false
    }

    //再调用相应的函数进行验证
    static propTypes = {
        a: PropTypes.number.isRequired,  //a属性必须是一个数字类型,并且必填
        b: PropTypes.bool.isRequired, //b必须是一个bool属性,并且必填
        onClick: PropTypes.func, //onClick必须是一个函数
        c: PropTypes.any, //1. 可以设置必填   2. 阵型保持整齐（所有属性都在该对象中）
        d: PropTypes.node.isRequired, //d必填，而且必须是一个可以渲染的内容，字符串、数字、React元素
        e: PropTypes.element, //e必须是一个React元素
        F: PropTypes.elementType, //F必须是一个组件类型 F={Comp}
        g: PropTypes.instanceOf(A), //g必须是A的实例
        sex: PropTypes.oneOf(["男", "女"]), //属性必须是数组当中的一个
        h: PropTypes.arrayOf(PropTypes.number), //数组的每一项必须满足类型要求
        i: PropTypes.objectOf(PropTypes.number), //每一个属性值必须满足类型要求
        j: PropTypes.shape({ //属性必须满足该对象的要求
            name: PropTypes.string.isRequired, //name必须是一个字符串，必填
            age: PropTypes.number, //age必须是一个数字
            address: PropTypes.shape({
                province: PropTypes.string,
                city: PropTypes.string
            })
        }),
        k: PropTypes.arrayOf(PropTypes.shape({
            name: PropTypes.string.isRequired,
            age: PropTypes.number.isRequired
        })),
        m: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
        score: function (props, propName, componentName) {
            console.log(props, propName, componentName);
            const val = props[propName];
            //必填
            if (val === undefined || val === null) {
                return new Error(`invalid prop ${propName} in ${componentName}，${propName} is Required`);
            }
            //该属性必须是一个数字
            if (typeof val !== "number") {
                return new Error(`invalid prop ${propName} in ${componentName}，${propName} is not a number`);
            }
            const err = PropTypes.number.isRequired(props, propName, componentName);
            if(err){
                return err;
            }
            //并且取值范围是0~100
            if (val < 0 || val > 100) {
                return new Error(`invalid prop ${propName} in ${componentName}，${propName} must is between 0 and 100`);
            }
        }
    }

    render() {
        const F = this.props.F;
        return (
            <div>
                {this.props.a}
                <div>
                    {this.props.d}
                    <F />
                </div>
            </div>
        )
    }
}

```

