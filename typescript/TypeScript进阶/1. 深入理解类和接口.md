# 深入理解类和接口



## 面向对象概述

### 为什么要学习面向对象

1. TS为前端面向对象开发提供了契机
   1. JS语言没有类型检查，如果使用面向对象的方式开发，类中则会产生大量的函数，从而导致[函数]调用复杂度剧增。过去，我们可以使用注释或文档对函数进行说明，但是由于此类方式不具有强约束力，导致开发者往往会不规范的调用函数，且不规范的调用函数导致的问题在代码运行时才能显现。
   2. TS提供了完整的类型系统，在使用面向对象的方式开发时，无论类中会包含多少函数，其中每个函数都能获得完整的类型检查，并且此类类型检查是具有强约束力的，在书写代码时，如果开发者不规范的调用函数，会立即在代码层面予以警告提示。
2. 面向对象中有许多非常成熟的模式，能很好的处理特定的复杂问题

### 什么是面向对象

面向对象：Oriented（基于）Object（事物），简称OO。

1. 面向对象是一种编程思想，以划分类（对象）为切入点思考问题
   1. 类：产生对象的模板
   2. `new 类()`：由类产生的不同的实例对象
2. 其他编程思想：面向过程、函数式编程 
   1. 面向过程：以功能流程为思考切入点，不太适合大型应用 
   2. 函数式编程：以数学运算为思考切入点



## 类的继承

### 继承的概述

> 继承可以描述类与类之间的关系 

例如：坦克、玩家坦克、敌方坦克 --> 玩家坦克是坦克，敌方坦克是坦克     

如果A和B都是类，并且可以描述为A是B，则A和B形成继承关系：

- B是父类，A是子类
- B派生A，A继承自B
- B是A的基类，A是B的派生类

**如果A继承自B，则A中自动拥有B中的所有成员**

### 成员的重写

> 重写：在子类中书写与父类同名的成员以覆盖父类对应成员

**注意：在TS中，无论是重写属性还是重写方法，都需要保证与父类对应的属性或方法的类型匹配。** 

**super关键字：在子类的方法中，可以使用super关键字读取父类成员**

### 类型匹配

鸭子辨型法：子类的实例对象，可以赋值给父类

如果需要判断一个数据的具体子类类型，可以使用instanceof

```typescript
//伪代码：
class Father{}
class Son1 extends Father{}
class Son2 extends Father{}
const f:Father = new Son1() //子类的实例对象，可以赋值给父类
f.成员 //此处仅能访问Father中的成员
if(f instanceof Son1){
	f.成员 //进入此if，则表明f是Son1的实例对象1，则额外的能访问Son1中的成员
}
```



### protected修饰符

**访问修饰符：控制类中某个成员的访问权限**

1. public：默认的访问修饰符，表示公开的，类和类的实例均可以访问（不写访问修饰符，则相当于书写了public）
2. private：私有的，仅在类中可以访问（可以理解为私有成员）
3. protected：受保护的，仅能在类与类的子类中可以访问

### 单根性和传递性

单根性：类仅能拥有一个父类

传递性：如果A是B的父类，B是C的父类，那么A是C的父类(祖先类)



## 抽象类

### 抽象类概述

 1. 抽象类通常作为其他类的基类（父类），用于提取子类中共有的成员
 2. 不能通过 `new 抽象类()`来创建对象，即抽象类是一种不能被实例化的类

```typescript
abstract class Chess {} // 通过在类之前添加 abstract 表示该类是一个抽象类
```

### 抽象成员

> 抽象成员是指在抽象类中：
>
> 1. 声明但没有赋值的属性
> 2. 声明但没有具体实现的方法（仅有方法签名，而没有方法体）

子类必须实现（覆盖）这些抽象成员，否则ts会提示错误。

抽象成员的存在使得抽象类无法被实例化，因为抽象类本身并没有提供属性的值和方法实现。

```typescript
abstract class Chess {
  // 定义抽象成员 在成员名之前添加 abstract 即可
  abstract readonly name: string;
  abstract move(targetX: number, targetY: number): boolean;
}

class Horse extends Chess {
  // 子类必须实现父类中的抽象成员，否则ts会提示错误
  readonly name: string = '马';
  move(targetX: number, targetY: number): boolean {
    //...
    return true;
  }
}
```

### 设计模式 - 模板模式

> 模板模式：某些方法，子类的实现流程完全一致，只是流程中的某个步骤的具体实现有区别。此时，可以将该方法提取到父类并在父类中完成整个流程的实现，对于流程中有区别的步骤，将其作为抽象方法由子类来实现。

**原始代码**

```typescript
abstract class Chess {
  abstract readonly name: string;
  abstract move(targetX: number, targetY: number): boolean;
}

class Horse extends Chess {
  readonly name: string = '马';
  move(targetX: number, targetY: number): boolean {
    // 1. 判断目标位置是否超出棋盘边界
    console.log('判断目标位置是否超出棋盘边界---代码');
    // 2. 判断目标位置是否已有己方棋子
    console.log('判断目标位置是否已有己方棋子---代码');
    // （区别） 3. 判断目标位置是否满足“马”的移动规则
    // 4. 移动到对应的位置
    console.log('移动到对应的位置---代码');
    return true;
  }
}

class Soldier extends Chess {
  readonly name: string = '兵';
  move(targetX: number, targetY: number): boolean {
    // 1. 判断目标位置是否超出棋盘边界
    console.log('判断目标位置是否超出棋盘边界---代码');
    // 2. 判断目标位置是否已有己方棋子
    console.log('判断目标位置是否已有己方棋子---代码');
    // （区别） 3. 判断目标位置是否满足“兵”的移动规则
    // 4. 移动到对应的位置
    console.log('移动到对应的位置---代码');
    return true;
  }
}

class Gun extends Chess {
  readonly name: string = '炮';
  move(targetX: number, targetY: number): boolean {
    // 1. 判断目标位置是否超出棋盘边界
    console.log('判断目标位置是否超出棋盘边界---代码');
    // 2. 判断目标位置是否已有己方棋子
    console.log('判断目标位置是否已有己方棋子---代码');
    // （区别） 3. 判断目标位置是否满足“炮”的移动规则
    // 4. 移动到对应的位置
    console.log('移动到对应的位置---代码');
    return true;
  }
}
```

**改动后的代码 - 模板模式**

```typescript
abstract class Chess {
  abstract readonly name: string;

  move(targetX: number, targetY: number): boolean {
    // 1. 判断目标位置是否超出棋盘边界
    console.log('判断目标位置是否超出棋盘边界---代码');
    // 2. 判断目标位置是否已有己方棋子
    console.log('判断目标位置是否已有己方棋子---代码');
    // （区别） 3. 判断目标位置是否满足“xxx”的移动规则
    this.moveRule();
    // 4. 移动到对应的位置
    console.log('移动到对应的位置---代码');
    return true;
  }

  protected abstract moveRule(): boolean;
}

class Horse extends Chess {
  readonly name: string = '马';
  protected moveRule(): boolean {
    console.log('判断目标位置是否满足“马”的移动规则');
    return true;
  }
}

class Soldier extends Chess {
  readonly name: string = '兵';
  protected moveRule(): boolean {
    console.log('判断目标位置是否满足“马”的移动规则');
    return true;
  }
}

class Gun extends Chess {
  readonly name: string = '炮';
  protected moveRule(): boolean {
    console.log('判断目标位置是否满足“马”的移动规则');
    return true;
  }
}
```



## 静态成员

> 静态成员：附着在类上的成员 `类.静态成员`

### 定义静态成员

```typescript
class ChessBoard {
  //在成员名之前添加 static 关键字定义静态成员
  static width: number = 300; 
  static height: number = 300;
  static overview(): void {
    console.log('I an a chessboard!');
  }
}

console.log(ChessBoard.width);
console.log(ChessBoard.height);
console.log(ChessBoard.overview());
```

### 静态方法中的 this

> 静态方法中的 this 始终指向类本身

### 设计模式 - 单例模式

> 单例模式是一种常见的设计模式，它的主要目的是确保一个类只有一个实例。

在单例模式中，**类的构造函数被限制为私有**，这样就无法通过常规的方式实例化该类（`new 类()`）。然后，该类提供一个静态方法或静态变量来获取唯一的实例。该静态方法或变量会在第一次调用时创建实例，并在后续调用中返回相同的实例。

单例模式的常见实现方式有两种：懒汉式和饿汉式。

1. 懒汉式单例模式：在懒汉式中，实例在调用静态创建方法时才会创建。如果该实例不存在，则会创建一个新的实例并返回。如果实例已经存在，则直接返回现有的实例。

   ```typescript
   class ChessBoard {
     static width: number = 300;
     static height: number = 300;
     private constructor() {}
   
     private static _chessboard?: ChessBoard;
   
     static createChessBoard() {
       if (ChessBoard._chessboard) {
         return ChessBoard._chessboard;
       } else {
         ChessBoard._chessboard = new ChessBoard();
         return ChessBoard._chessboard;
       }
     }
   }
   
   // const cb = new ChessBoard(); // 类“ChessBoard”的构造函数是私有的，仅可在类声明中访问
   const cb1 = ChessBoard.createChessBoard();
   const cb2 = ChessBoard.createChessBoard();
   console.log(cb1 === cb2); // true
   ```

   

2. 饿汉式单例模式：在饿汉式中，实例在类加载时就被创建，无论是否使用它。因此，它的实例是在程序启动时就创建好的，因此称为"饿汉"。

   ```typescript
   class ChessBoard {
     static width: number = 300;
     static height: number = 300;
     private constructor() {}
   
     static readonly chessboard = new ChessBoard(); // 此类方式不常用，此处仅能书写 new ChessBoard()，如果在此之前需要做一些额外处理则只能使用方式1
   }
   
   // const cb = new ChessBoard(); // 类“ChessBoard”的构造函数是私有的，仅可在类声明中访问
   const cb1 = ChessBoard.chessboard;
   const cb2 = ChessBoard.chessboard;
   console.log(cb1 === cb2); // true
   ```



## 再谈接口

### 面向对象中的接口

面向对象领域中的接口含义：表达了某个类是否具有某种能力（即该类是否实现了接口）

**原始代码**

```typescript
abstract class Person {
  abstract name: string;
  abstract age: number;
  abstract career: string;

  selfIntroduction() {
    console.log(`姓名:${this.name},年龄:${this.age},职业:${this.career}.`);
  }
}

class BasketballPlayer extends Person {
  name: string;
  age: number;
  career: string = '篮球运动员';
  constructor(name: string, age: number) {
    super();
    this.name = name;
    this.age = age;
  }
  playing() {
    console.log(`我是${this.name},职业是${this.career},我会打篮球`);
  }
}

class Programmer extends Person {
  name: string;
  age: number;
  career: string = '程序员';
  constructor(name: string, age: number) {
    super();
    this.name = name;
    this.age = age;
  }

  coding() {
    console.log(`我是${this.name},职业是${this.career},我会写代码`);
  }
}

class Teacher extends Person {
  name: string;
  age: number;
  career: string = '教师';
  constructor(name: string, age: number) {
    super();
    this.name = name;
    this.age = age;
  }

  teaching() {
    console.log(`我是${this.name},职业是${this.career},我会教书`);
  }
}

const persons: Person[] = [
  new BasketballPlayer('kobe', 35),
  new Programmer('尤雨溪', 30),
  new Teacher('YZ', 33),
];

// 查看哪些人会打篮球
persons.forEach((p) => {
  // 此处判断本意是判断哪些人会打篮球,但是由于系统中缺少会打篮球的人的标识,被迫只能判断该人的职业是不是篮球运动员
  // (代码含有隐患,例如如果有一天篮球运动员受伤了不能打篮球了,则系统中会有大量的类型代码需要修改)
  // 此时,应该使用接口来描述(标识)会打篮球
  if (p instanceof BasketballPlayer) {
    p.playing();
  }
});
```

### 实现接口与类型保护函数

**添加接口代码**

> 实现接口：`implements 接口名称`

类型保护函数：通过调用该函数，会触发TS的类型保护，该函数必须返回boolean

```js
interface IPlaying {
  playing: () => void;
}
interface ICoding {
  coding: () => void;
}
interface ITeaching {
  teaching: () => void;
}

abstract class Person {
  abstract name: string;
  abstract age: number;
  abstract career: string;

  selfIntroduction() {
    console.log(`姓名:${this.name},年龄:${this.age},职业:${this.career}.`);
  }
}

class BasketballPlayer extends Person implements IPlaying {
  name: string;
  age: number;
  career: string = '篮球运动员';
  constructor(name: string, age: number) {
    super();
    this.name = name;
    this.age = age;
  }
  playing() {
    console.log(`我是${this.name},职业是${this.career},我会打篮球`);
  }
}

class Programmer extends Person implements ICoding, IPlaying {
  name: string;
  age: number;
  career: string = '程序员';
  constructor(name: string, age: number) {
    super();
    this.name = name;
    this.age = age;
  }

  coding() {
    console.log(`我是${this.name},职业是${this.career},我会写代码`);
  }

  playing() {
    console.log(`我是${this.name},职业是${this.career},我会打篮球`);
  }
}

class Teacher extends Person implements ITeaching {
  name: string;
  age: number;
  career: string = '教师';
  constructor(name: string, age: number) {
    super();
    this.name = name;
    this.age = age;
  }

  teaching() {
    console.log(`我是${this.name},职业是${this.career},我会教书`);
  }
}

const persons: Person[] = [
  new BasketballPlayer('kobe', 35),
  new Programmer('尤雨溪', 30),
  new Teacher('YZ', 33),
];

// 书写类型保护函数
function canPlaying(p: object): p is IPlaying {
  if ((p as IPlaying).playing) {
    return true;
  } else {
    return false;
  }
}

// 查看哪些人会打篮球
persons.forEach((p) => {
  // 现在才是真正意义上判断某人是否会打篮球
  // 同时后续如果有人从 (会打篮球->不会打篮球,直接不让其实现该接口即可)(不会打篮球->会打篮球,额为实现一个 IPlaying 接口即可)
  if (canPlaying(p)) {
    //此处只有通过书写类型保护函数,下一行代码才能够得到完整的智能提示
    p.playing();
  }
});
```

### 接口继承类

额外的知识点：接口可以继承类，表示该接口必须包含类中的所有成员



## 索引器

### 成员表达式

成员表达式：`对象[值]`

在TS中，默认情况下，不对成员表达式进行严格的类型检查

```typescript
class User {
  constructor(public name: string, public age: number) {}
}

const u = new User('kobe', 35);
// console.log(u.love); // ts错误提示: 类型“User”上不存在属性“love”。
console.log(u['love']); //undefined
```

如果我们希望成员表达式进行严格的类型检查，则需要配置编译选项`"noImplicitAny": true`，以开启对隐式any类型（TS推导出来为any类型）的检查

### 使用索引器

**未使用索引器**

在ts中，不允许我们动态的为类的实例对象添加属性：

```typescript
class User {
  constructor(public name: string, public age: number) {}
}

const u = new User('kobe', 35);

u.love = 'basketball'; //ts错误提示:类型“User”上不存在属性“love”。
```

如果希望ts能够为类的实例对象动态添加属性，需要为该类添加索引器（索引器书写的位置在所有成员之前）

```typescript
class User {
  [prop: string]: any; // 索引器代码（此处可配置多个索引器，但需要保证不会冲突）
  constructor(public name: string, public age: number) {}
}

const u = new User('kobe', 35);

u.love = 'basketball'; //ts错误提示:类型“User”上不存在属性“love”。
```

### 索引器的作用

1. 在严格的类型检查下，能够为类的实例对象动态的添加成员
2. 可以实现动态读取类成员（即使用成员表达式进行读取）



## this 指向约束

### JS中this指向问题

过去，函数的不同的调用方式会导致函数中的this指向不尽相同

```typescript
const user = {
  name: 'kobe',
  age: 35,
  selfIntroduction() {
    console.log(this.name, this.age, this); //此处TS将this推导为any类型,因为TS无法预知开发者通过哪种方式调用该函数,不同的调用方式会导致this指向不同
  },
};

const s = user.selfIntroduction;
s(); // undefined undefined  Object[global]

class User {
  constructor(public name: string, public age: number) {}
  selfIntroduction() {
    console.log(this.name, this.age, this); // 此处TS将this推导为User类型,因为直接类中默认开启了严格模式,直接调用函数this指向undefined
  }
}

const u = new User('YZ', 18);
const s2 = u.selfIntroduction;
s2(); //TypeError: Cannot read properties of undefined (reading 'name') --- 由于JS中类中的代码默认开启了严格模式,所以此处直接调用函数this指向undefined
```

### TS手动约束this指向

配置`"noImplicitThis": true`，表示不允许this被TS推导出来隐式指向any

在TS中，允许在书写函数时，手动声明该函数中的this指向（将this书写在函数的第一个参数位置处，该位置仅用于约束this指向，并不是真正的参数，也不会出现在编译结果中）

```typescript
interface IUser {
  name: string;
  age: number;
  selfIntroduction(this: IUser): void; //手动指定函数中的this指向为 IUser,如果TS发现在调用函数时this指向有变化,会在代码层面进行错误提示
}

const user: IUser = {
  name: 'kobe',
  age: 35,
  selfIntroduction() {
    console.log(this.name, this.age, this); 
  },
};

const s = user.selfIntroduction;
s();  //ts错误提示: 类型为“void”的 "this" 上下文不能分配给类型为“IUser”的方法的 "this"。

class User {
  constructor(public name: string, public age: number) {}
  selfIntroduction(this: User) {
    console.log(this.name, this.age, this); 
  }
}
```

