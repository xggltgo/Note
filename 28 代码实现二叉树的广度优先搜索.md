# 代码实现二叉树的广度优先搜索

> 实现核心：维护一个同层节点数组

```js
function Node(val) {
  this.val = val;
  this.left = null;
  this.right = null;
}

const A = new Node('A');
const B = new Node('B');
const C = new Node('C');
const D = new Node('D');
const E = new Node('E');
const F = new Node('F');
const G = new Node('G');

A.left = B;
A.right = C;
B.left = D;
B.right = E;
C.left = F;
C.right = G;

function breadthFirstSearch(sameLayerNodes, nodeVal) {
  if (sameLayerNodes === null || sameLayerNodes.length === 0) {
    return false;
  }
  for (let i = 0; i < sameLayerNodes.length; i++) {
    const val = sameLayerNodes[i].val;
    if (val === nodeVal) {
      return true;
    }
  }
  const childNodes = [];
  sameLayerNodes.forEach((node) => {
    node.left && childNodes.push(node.left);
    node.right && childNodes.push(node.right);
  });
  return (
    breadthFirstSearch(childNodes, nodeVal) ||
    breadthFirstSearch(childNodes, nodeVal)
  );
}

console.log(breadthFirstSearch([A], 'A'));
console.log(breadthFirstSearch([A], 'B'));
console.log(breadthFirstSearch([A], 'C'));
console.log(breadthFirstSearch([A], 'D'));
console.log(breadthFirstSearch([A], 'E'));
console.log(breadthFirstSearch([A], 'F'));
console.log(breadthFirstSearch([A], 'G'));
console.log(breadthFirstSearch([A], 'H'));

// 输出结果如下：
// true
// true
// true
// true
// true
// true
// true
// false
```

