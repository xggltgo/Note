# 实现Route

![image-20220731225305761](6-5.实现Route/image-20220731225305761.png)

## 分析Route

**核心：匹配路由，并把匹配的结果放到上下文中**

**每一个Route，由于路径匹配规则不同，所以应当得到不同match对象，并放置到上下文中**

## 封装 Route组件

```js
// //用于匹配路由，并将匹配的结果放入到上下文中
import React, { Component } from 'react';
import ctx from './RouterContext';
import matchPath from './matchPath';

export default class Route extends Component {
  /*
    path：路径规则，可以是字符串，可以是字符串数组
    children：无论是否匹配，都应该渲染的子元素
    render：匹配成功后，渲染函数
    component：匹配成功后，渲染的组件

    以下是调用matchPath方法时的配置
    exact
    strict
    sensitive
    */

  /**
   * 根据指定的location对象，返回match对象
   */
  handleMatch(location) {
    const { exact = false, sensitive = false, strict = false } = this.props;
    const options = { exact, sensitive, strict };
    return matchPath(this.props.path || '/', location.pathname, options);
  }

  /**
   * 上下文中消费者函数
   */
  handleCtxProvider = (value) => {
    const ctxValue = {};
    ctxValue.history = value.history;
    ctxValue.location = value.location;
    //处理match
    ctxValue.match = this.handleMatch(value.location);
    return (
      <ctx.Provider value={ctxValue}>
        {this.handleRender(ctxValue)}
      </ctx.Provider>
    );
  };

  /**
   * 在上下文提供者内部渲染的内容
   * @param {*} ctx
   */
  handleRender(ctx) {
    //处理children
    if (this.props.children !== undefined && this.props.children !== null) {
      if (typeof this.props.children === 'function') {
        return this.props.children(ctx);
      } else {
        if (ctx.match) {
          return this.props.children;
        }
      }
    }
    //处理匹配上的情况
    if (ctx.match) {
      //优先处理component
      const { component: Component } = this.props;
      if (Component) {
        return <Component {...ctx} />;
      }
      //处理render
      if (typeof this.props.render === 'function') {
        return this.props.render(ctx);
      }
    }

    return null;
  }

  render() {
    return <ctx.Consumer>{this.handleCtxProvider}</ctx.Consumer>;
  }
}
```





