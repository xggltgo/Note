# 装饰器

## 装饰器概述

> Decorator：面向对象的概念（Java：注解，C#：特征）

目前 JS 支持装饰器，但还没有成为正式标准

### 装饰器解决的问题

装饰器，用于添加额外的信息量，以达到横切关注点的目的。

### 装饰器的作用

装饰器可以提供额外的元数据信息（metadata）

### 装饰器的本质

在JavaScript中，装饰器是一个函数。（因此，装饰器需要参与运行）

装饰器可以修饰：

- 类本身
- 类的成员
- 参数



## 类装饰器

> 类装饰器的本质是一个函数，该函数接收一个参数，表示类本身（构造函数本身）

### 定义装饰器

定义类的前一行添加`@装饰器函数`

在TS中如果需要使用装饰器，需要添加编译选项配置`"experimentalDecorators": true`

在TS中，如何约束变量的类型为一个类

- Function
- `new (参数) => object`，参数通常写为`...args:any[]`，以兼容类参数数量不定的情况

```typescript
function d1(targetClass: new () => object) { // 约束参数的类型为一个类
  console.log(targetClass); //[class A]
}

@d1 // 定义类的前一行添加`@装饰器函数`
class A {}
```

### 装饰器运行时间点

装饰器在类定义完成后就会得到运行

**上方代码编译后的代码**

```js
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function d1(targetClass) {
    console.log(targetClass);
}
let A = class A {
};
A = __decorate([ // 装饰器在类定义完成后就会得到运行
    d1
], A);
```

### 装饰器函数的返回值

类装饰器可以具有的返回值：

1. void：无返回值，仅运行函数

2. 返回一个新的类：该类会替换掉原始装饰目标

   ```typescript
   function d1(targetClass: new () => object) {
     return class B {};
     //   return class B extends targetClass {}; //借助此特性，此处可以书写原始装饰目标的子类，以实现对原始类的功能的扩充
   }
   
   @d1
   class A {}
   
   const obj = new A();
   console.log(obj); // B {}
   ```

### 多个装饰器的调用顺序

多个装饰器的顺序（洋葱法：由里向外）

```typescript
function d1(targetClass: new () => object) {
  console.log('d1');
}
function d2(targetClass: new () => object) {
  console.log('d2');
}

@d1
@d2
class A {} //输出顺序: d2 d1
```

### 高阶装饰器

`@`后面可以书写函数调用，只要最终返回的是一个装饰器格式的函数即可。

```typescript
type TClass = new () => object;

function d1(meta: string) {
  return function (targetClass: TClass) {
    console.log('d1',meta);
  };
}

function d2(meta: string) {
  return function (targetClass: TClass) {
    console.log('d2',meta);
  };
}

@d1('d1额外信息')
@d2('d2额外信息')
class A {} //输出顺序: d2 d1
```

### 面试题

以下代码的输出顺序：
```typescript
type TClass = new () => object;

function d1(meta: string) {
  console.log(meta);

  return function (targetClass: TClass) {
    console.log('d1');
  };
}

function d2(meta: string) {
  console.log(meta);

  return function (targetClass: TClass) {
    console.log('d2');
  };
}

@d1('d1额外信息')
@d2('d2额外信息')
class A {} //输出顺序: d1额外信息 d2额外信息 d2 d1
```

**编译结果：**

```typescript
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function d1(meta) {
    console.log(meta);
    return function (targetClass) {
        console.log('d1');
    };
}
function d2(meta) {
    console.log(meta);
    return function (targetClass) {
        console.log('d2');
    };
}
let A = class A {
};
A = __decorate([
    d1('d1额外信息'),
    d2('d2额外信息')
], A);
```



## 成员装饰器

### 成员装饰器 - 属性

属性装饰器也是一个函数，该函数有两个参数：

- 参数1：如果是静态属性，则为类本身（构造函数）；如果是实例属性，则为类的原型
- 参数2：装饰器所修饰的属性名（字符串）

```typescript
function d(target: any, key: string) {
  console.log(target === A.prototype, key); // true prop1
}

class A {
  @d
  prop1: string;
  prop2: string;
}
```

### 成员装饰器 - 方法

方法装饰器也是一个函数，该函数有三个参数：

- 参数1：如果是静态方法，则为类本身（构造函数）；如果是实例方法，则为类的原型
- 参数2：装饰器所修饰的方法名（字符串）
- 参数3：所修饰方法的属性描述符(Object.defineProperty的第三个参数)

```typescript
class Test {
  @Obsolete //标识print函数过时 名称可自定义
  print() {
    console.log('this is print!');
  }
}

/**
 *
 * @param {*} target 当前类
 * @param {*} methodName 所修饰的方法名
 * @param {*} descriptor 所修饰方法的属性描述符(Object.defineProperty的第三个参数)
 */
function Obsolete(
  target: any,
  methodName: string,
  descriptor: PropertyDescriptor
) {
  const oldFn = descriptor.value;
  descriptor.value = function (...args: any[]) {
    console.warn(`${methodName}方法已经过时了`);
    oldFn.apply(this, args);
  };
}

const t = new Test();
t.print();
```

### 高阶装饰器

`@`后面可以书写函数调用，只要最终返回的是一个装饰器格式的函数即可。

### 多个装饰器

与类装饰器多个情况运行顺序相同

## reflect-metadata 库

> 该库的作用：保存元数据
>
> npm地址：https://www.npmjs.com/package/reflect-metadata

## class-validator和class-transformer

以上两个库【可能】需要提前安装 `reflect-metadata` 库

> class-validator地址：https://www.npmjs.com/package/class-validator
>
> class-validator作用：验证

> class-transformer地址：https://www.npmjs.com/package/class-transformer
>
> class-transformer作用：平面对象转换为类的对象，以获得类中的额外函数



## 装饰器补充

### 参数装饰器

参数装饰器往往在大型项目中的依赖注入（依赖倒置）会使用到

参数装饰器是一个函数，该函数有三个参数：

- 参数1：如果是静态方法，则为类本身（构造函数）；如果是实例方法，则为类的原型
- 参数2：装饰器所修饰的方法名（字符串）
- 参数3：参数位置索引值

```typescript
function d(target: any, methodName: string, propIndex: number) {
  console.log(target, methodName, propIndex); // {} sum 1
}

class MyMath {
  sum(a: number, @d b: number): number {
    return a + b;
  }
}
```

### TS自动注入的元数据

如果安装并导入了 `reflect-metadata` 库，同时在某个成员位置添加了元数据，再同时配置了编译选项`"emitDecoratorMetadata": true`（表示启用元数据），则：

- TS的编译结果中，会将我们手动约束的类型作为额外的元数据添加到相应位置
- 这样一来，TS的类型检查将有机会在运行时进行

 **原始代码**

```typescript
import 'reflect-metadata';

class A {
  @Reflect.metadata('p1', 0)
  prop1: string;
  @Reflect.metadata('p2', 1)
  prop2: number;
}
```

**编译结果**

```typescript
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
class A {
}
__decorate([
    Reflect.metadata('p1', 0),
    __metadata("design:type", String) // 手动约束的类型作为额外的元数据保存
], A.prototype, "prop1", void 0);
__decorate([
    Reflect.metadata('p2', 1),
    __metadata("design:type", Number) // 手动约束的类型作为额外的元数据保存
], A.prototype, "prop2", void 0);
```

### AOP

> AOP（Aspect-Oriented Programming）是一种编程范式，旨在通过将横切关注点（cross-cutting concerns）与核心业务逻辑分离，以提供更好的模块化和可维护性。

