# 手写saga

**习惯过了头：核心（saga中间件，在yield后面的内置指令会返回一个指令对象，然后saga中间件会根据该指令对象的不同类型，而进行不同的处理）**

saga中间件的原理：

1. 首先启动一个任务
2. 当action触发时，直接将action分发到下一个中间件



**redux-saga/index.js**

默认导出一个函数，该函数用于创建一个saga中间件。

同时saga中间件提供了一个静态方法run（即runSaga方法），用于启动一个任务。

```js
import runSaga from './runSaga';
import Channel from './Channel';

//redux-saga中间件创建函数
export default function () {
  function sagaMiddleware(store) {
    const env = {
      store,
      channel: new Channel(), //全局唯一的订阅频道
    };
    sagaMiddleware.run = runSaga.bind(null, env);
    return function (next) {
      return function (action) {
        const result = next(action); //直接交给下一个中间件处理
        env.channel.put(action.type, action);
        return result;
      };
    };
  }

  return sagaMiddleware;
}
```



**redux-runSaga.js**

导出一个函数，用于启动一个任务（生成器函数）；每个任务会返回一个task，用于后续取消任务使用

task

```js
export default class Task {
  constructor(next, callbackObj, empty) {
    this.next = next;
    this.empty = empty;
    this.cbObj = callbackObj;
    this.cbObj.callback = () => {
      this.resolve && this.resolve();
    };
  }

  cancel() {
    this.next(null, null, true);
  }

  toPromise() {
    return new Promise((resolve) => {
      if (this.empty) {
        resolve();
      }
      this.resolve = resolve;
    });
  }
}
```

函数内部会调用传递的生成器函数，得到生成器。然后利用递归工具函数next，不断迭代生成器，在迭代过程中，如果yiled表达式返回的结果会作为下一次next的参数。

不同的yiled表达式返回的结果会进行不同的处理：

- 如果是effect object（内置指令对象），会交给特定的函数`runEffect(env, value, next);`处理
- 如果是Promise，则会等待该promise完成后再进行下一次迭代
- 如果是普通值，则直接开始下一次迭代

```js
import isGenerator from 'is-generator';
import Task from './Task';
import { isEffectObject } from './effectHelper';
import isPromise from 'is-promise';
import runEffect from './runEffect';

/**
 * 启动一个saga任务
 * @param {*} env 全局共享的环境数据
 * @param {*} generatorCreator 生成器函数
 */
export default function (env, generatorCreator, ...args) {
  const generator = generatorCreator(...args);
  //判断generatorCreator的返回结果是否是一个生成器
  if (isGenerator(generator)) {
    //不断调用next，直到迭代结束
    return proc(env, generator);
  } else {
    console.log('一个普通函数');
  }
}

export function proc(env, generator) {
  const callbackObj = {
    callback: null,
  };

  let empty = null;

  next();
  /**
   * 根据yield表达式的值，不断迭代
   * @param {*} nextValue 下一次generator.next()的参数
   * @param {*} err generator.throw()的参数
   * @param {*} isOver generator.return()
   */
  function next(nextValue, err, isOver) {
    let result; //记录迭代的结果 {value: xxx, done: false}
    if (err) {
      result = generator.throw(err);
    } else if (isOver) {
      result = generator.return();
      callbackObj.callback && callbackObj.callback();
    } else {
      // 正常迭代
      result = generator.next(nextValue);
    }
    //解构出value和done
    const { value, done } = result;
    if (done) {
      //迭代结束了
      empty = true;
      callbackObj.callback && callbackObj.callback();
      return;
    } else {
      //没有结束
      if (isEffectObject(value)) {
        //情况1：是一个effect对象
        runEffect(env, value, next);
      } else if (isPromise(value)) {
        //情况2：value是一个promise
        value.then((res) => next(res)).catch((err) => next(null, err));
      } else {
        //情况3：其他
        next(value); //直接进行下一步
      }
    }
  }

  return new Task(next, callbackObj, empty);
}
```



**redux-saga/runEffect.js**

根据传递的指令对象不同的type属性，进行不同的处理

```js
import { effectObjectTypes } from './effectHelper';
import { runCallEffect } from './effects/call';
import { runPutEffect } from './effects/put';
import { runSelectEffect } from './effects/select';
import { runTakeEffect } from './effects/take';
import { runForkEffect } from './effects/fork';
import { runCancelEffect } from './effects/cancel';
import { runAllEffect } from './effects/all';
/**
 * 根据effectObject的type，进行不同的处理
 * @param {*} env 全局共享数据
 * @param {*} value effectObject
 * @param {*} next 迭代函数
 */
export default function (env, value, next) {
  switch (value.type) {
    case effectObjectTypes.CALL:
      runCallEffect(env, value, next);
      break;
    case effectObjectTypes.PUT:
      runPutEffect(env, value, next);
      break;
    case effectObjectTypes.SELECT:
      runSelectEffect(env, value, next);
      break;
    case effectObjectTypes.TAKE:
      runTakeEffect(env, value, next);
      break;
    case effectObjectTypes.FORK:
      runForkEffect(env, value, next);
      break;
    case effectObjectTypes.CANCEL:
      runCancelEffect(env, value, next);
      break;
    case effectObjectTypes.ALL:
      runAllEffect(env, value, next);
      break;
    default:
      throw new Error('invalid type');
  }
}
```

**redux-saga/effectHelper.js**

辅助模块

- 提供不同指令对象的type属性
- 提供创建指令对象的函数
- 提供判断一个对象是否是指令对象的函数

```js
export const effectObjectTypes = {
  CALL: 'CALL',
  PUT: 'PUT',
  SELECT: 'SELECT',
  TAKE: 'TAKE',
  FORK: 'FORK',
  CANCEL: 'CANCEL',
  TAKEEVERY: 'TAKEEVERY',
  ALL: 'ALL',
};

const effectObjectSign = '@@redux-saga/IO';

export function createEffectObject(type, payload) {
  if (!Object.values(effectObjectTypes).includes(type)) {
    throw new TypeError('invalid type');
  }
  return {
    [effectObjectSign]: true,
    payload,
    type,
  };
}

export function isEffectObject(obj) {
  if (typeof obj !== 'object') {
    return false;
  }
  if (!obj[effectObjectSign]) {
    return false;
  }
  return true;
}
```

**redux-saga/Channel**

发布订阅模块，用于take监听action触发

```js
/**
 * 维护一个全局的发布订阅频道
 */
export default class Channel {
  // 维护一个管理订阅的对象
  listeners = {};

  /**
   * 添加一个订阅
   * @param {*} actionType 订阅的属性名
   * @param {*} fn 添加的函数
   */
  take(actionType, fn) {
    if (this.listeners[actionType]) {
      this.listeners[actionType].push(fn);
    } else {
      this.listeners[actionType] = [fn];
    }
  }

  put(actionType, ...args) {
    if (this.listeners[actionType]) {
      const funcs = this.listeners[actionType];
      delete this.listeners[actionType];
      for (const func of funcs) {
        func(...args);
      }
    }
  }
}
```

  

**redux-saga/effects文件夹**

这里以**take.js**为例子

无非是根据take参数导出一个take函数，用于返回一个take指令对象

runTakeEffect:则是当返回的指令对象是take时，运行的处理函数

```js
import { createEffectObject, effectObjectTypes } from '../effectHelper';

export function take(actionType) {
  return createEffectObject(effectObjectTypes.TAKE, {
    actionType,
  });
}

export function runTakeEffect(env, value, next) {
  const actionType = value.payload.actionType;
  env.channel.take(actionType, (action) => {
    //订阅函数，当action发生的时候要运行的函数
    next(action);
  });
}

```

