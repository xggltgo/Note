#   TS中的类

## 概述

由于面向对象思想对于前端同学不易理解，此篇文档有仅作为TS中的类的基础部分，因此仅讨论新增的语法

## 新增的类语法 

### 属性列表

过去，在JS代码中我们可以使用如下的方式动态的给类添加属性

```js
class User {
    constructor(name,age){
        this.name = name;
        this.age = age;
    }
}
```

但是，在TS中动态的给类添加属性则会报错。**TS要求使用属性列表来预先描述类中的属性**

```typescript
//但是，在TS中动态的给类添加属性则会报错如下：
class User {
    constructor(name:string,age:number){
        this.name = name; //类型“User”上不存在属性“name”。
        this.age = age;
    }
}

//正确的书写方式（书写属性列表） 
class User {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}
```

**注意：**为了防止我们忘记使用属性列表的属性，可以添加编译选项`"strictPropertyInitialization": true`到TS配置文件中，以开启更加严格的属性初始化检查

```json
{
  "compilerOptions": {
    //编译选项
    "target": "ES2016", //配置编译目标代码（编译结果）的版本标准
    "module": "CommonJS", //配置编译目标代码（编译结果）使用的模块化标准
    "lib": ["ES2016"], //配置ts可使用的全局环境 默认会有 "DOM" (浏览器环境) 此处没有node环境可供配置
    "outDir": "./dist", //配置编译结果的输出目录 
    "strictNullChecks": true, //以获得更加严格的空类型检查，null和undefined不再能够赋值给其他类型，只能赋值给自身
    "removeComments": true, //编译结果移除注释
    "noImplicitUseStrict": true, //编译结果中移除“use strict”
    "esModuleInterop": true, //启用es模块化与非es模块导出进行交互
    "noEmitOnError": true, //代码错误时不生成编译结果
    "moduleResolution": "Node", //设置解析模块的模式
    "strictPropertyInitialization": true, //适用于类中开启更严格的属性初始化检查，防止开发者忘记初始化属性列表对应属性
  },
  "include": ["./src"] //配置需要编译(ts->js)的文件夹
  // "files": ["./src/index.ts"] //若不是需要编译整个文件夹，而是文件夹中特定的文件，则使用此配置（此配置会编译所配置的文件及其依赖的文件，类似于入口模块）
}
```



### 属性的初始化位置

1. 构造函数中

2. 属性列表赋默认值

   1. 书写默认值的方式1（此处属性初始化的位置也是在构造函数中）

      ```typescript
      class User {
        name: string;
        age: number;
        sex: '男' | '女';
      
        constructor(name: string, age: number,sex:'男' | '女' = '男') {
          this.name = name;
          this.age = age;
          this.sex = sex;
        }
      }
      ```

   2. 书写默认值的方式2

      ```typescript
      class User {
        name: string;
        age: number;
        sex: '男' | '女' = '男';
      
        constructor(name: string, age: number) {
          this.name = name;
          this.age = age;
        }
      }
      ```



### 可选属性、只读属性

属性可以修饰为可选的，可选属性可以不初始化

属性可以修饰为只读的，只读属性后续无法更改

```typescript
class User {
  readonly id: number; //只读属性
  name: string;
  age: number;
  sex: '男' | '女' = '男';
  love?: string; //可选属性

  constructor(name: string, age: number) {
    this.id = Math.random();
    this.name = name;
    this.age = age;
  }
}
```



### 访问修饰符

**访问修饰符：控制类中某个成员的访问权限**

1. public：默认的访问修饰符，表示公开的，类和类的实例均可以访问（不写访问修饰符，则相当于书写了public）
2. private：私有的，仅在类中可以访问（可以理解为私有成 员）
3. protected：受保护的，仅能在类与类的子类中可以访问

```typescript
class User {
  readonly id: number;
  name: string;
  age: number;
  sex: '男' | '女' = '男';
  love?: string;
  private _idcard: string = '0127021'; //身份证号 私有属性

  constructor(name: string, age: number) {
    this.id = Math.random();
    this.name = name;
    this.age = age;
  }

  private _encryptionIdcard(): string { //内部私有工具方法 仅返回后四位身份证号，其余使用*代替
    let idcard = '';
    const n = this._idcard.length - 5;
    for (let i = 0; i <= n; i++) {
      idcard += '*';
    }
    idcard += this._idcard.substring(n + 1);
    return idcard;
  }

  getIdcard() { //暴露给核算检测人员看的后四位身份证号
    return this._encryptionIdcard();
  }
}

const u = new User('xgglt',20);

const idcard = u.getIdcard()
console.log(idcard);  //***7021
```



### **属性简写**

如果某个属性，通过构造函数的参数传递，并且在构造函数中不做任何额外处理，直接赋值给对应的属性：==可以简写==（**但需要在构造函数参数位置加上任意访问修饰符**）

```typescript
// 完整版
class User {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

//简写版（shu'x列表、构造函数中对应代码）
class User {
  constructor(public name: string, public age: number) {
    
  }
}
```





## 访问器

> 作用：用于控制属性的读取和赋值

例：限制用户的年龄在0~200之间

方式1：利用函数控制（类似于JAVA中的实现方式），此方式给人一种实例中没有age这个属性，不够直观。

```typescript
class User {
  constructor(public name: string, private _age: number) {}

  setAge(value: number) {
    if (value < 0) {
      this._age = 0;
    } else if (value >= 200) {
      this._age = 200;
    } else {
      this._age = value;
    }
  }

  getAge() {
    return Math.ceil(this._age);
  }
}

const u = new User('xgglt', 20);
u.setAge(20.5);
console.log(u.getAge()); //21
u.setAge(-1);
console.log(u.getAge()); //0
u.setAge(300);
console.log(u.getAge()); //200
```

方式2：利用访问器（语法糖，本质也是函数）

```typescript
class User {
  constructor(public name: string, private _age: number) {}

  set age(value: number) {
    if (value < 0) {
      this._age = 0;
    } else if (value >= 200) {
      this._age = 200;
    } else {
      this._age = value;
    }
  }

  get age() {
    return Math.ceil(this._age);
  }
}

const u = new User('xgglt', 20);
u.age = 20.5;
console.log(u.age); //21
u.age = -1;
console.log(u.age); //0
u.age = 300;
console.log(u.age); //200
```

