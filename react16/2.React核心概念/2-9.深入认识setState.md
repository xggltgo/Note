# 深入认识setState

setState，它对状态的改变，**可能**是异步的

因此，并不是代码执行到this.setState()就会立即重新渲染，而是会等到将来异步的调用this.setState且状态真实发生改变后，才会重新渲染

> **如果改变态的代码处于某个HTML元素的事件中，则其是异步的**，否则是同步（18版本都是异步）


最佳实践：

1. 把所有的setState当作是异步的

2. 永远不要信任setState调用之后的状态

3. 如果要使用改变之后的状态，需要使用回调函数（传递setState的第二个参数）

   ```js
    this.setState({
         n: this.state.n + 1
      }, () => {
      // 状态完成改变之后触发，该回调运行在render之后
         console.log(this.state.n); 
    });

4. 如果新的状态要根据之前的状态进行运算，那么需要传递一个函数作为setState的参数

   **注意**：无论`this.setState()`函数，所接收的参数是对象还是函数，其对状态的改变都是异步的，如果需要改变之后的状态，需要传递第二个参数（回调函数）

   > 使用场景：如果在某个事件处理函数中，需要多次同步改变状态

    ```js
    handleClick = () => {
         this.setState(cur => {
         //参数cur表示当前的状态
         //该函数的返回结果，会混合（覆盖）掉之前的状态
         //该函数是异步执行
          return {
             n: cur.n + 1
            }
          }, ()=>{
                //所有状态全部更新完成，并且重新渲染后执行
                console.log("state更新完成", this.state.n); // 3
          });
    
        this.setState(cur => ({
              n: cur.n + 1
         }));
    
         this.setState(cur => ({
              n: cur.n + 1
         }));
    }
    ```

**注意：**React会对异步的setState进行优化，会在内部维护一个队列，将多次setState进行合并，合并后再统一对state进行改变，然后触发render。因此，代码块中的hanldeClick函数仅会触发一次重新渲染（render）；





