# plugin

## 简介

loader的功能定位是转换代码，而一些其他的操作难以使用loader完成，比如：

- 当webpack生成文件时，顺便多生成一个说明描述文件
- 当webpack编译启动时，控制台输出一句话表示webpack启动了
- 当xxx时，xxx

这种类似的功能需要把功能嵌入到webpack的编译流程中，而这种事情的实现是依托于plugin的

![](assets/2020-01-15-12-45-16.png)

> plugin的本质是一个带有apply方法的对象

```js
var plugin = {
    apply: function(compiler){
        
    }
}
```

> 通常，习惯上，我们会将该对象写成构造函数的模式

```js
class MyPlugin{
    apply(compiler){
				//apply函数内部注册事件
    }
}

var plugin = new MyPlugin();
```

要将插件应用到webpack，需要把插件对象配置到webpack的plugins数组中，如下：

```js
module.exports = {
    plugins:[
        new MyPlugin()
    ]
}
```

apply函数会在初始化阶段，创建好Compiler对象后运行。

compiler对象是在初始化阶段构建的，整个webpack打包期间只有一个compiler对象，后续完成打包工作的是compiler对象内部创建的compilation

apply方法会在**创建好compiler对象后调用**，并向方法传入一个compiler对象

![](assets/2020-01-15-12-49-26.png)

compiler对象提供了大量的钩子函数（hooks，可以理解为事件），plugin的开发者可以注册这些钩子函数，参与webpack编译和生成。

## 注册钩子函数

```js
class MyPlugin{
    apply(compiler){
        compiler.hooks.事件名称.事件类型(name, function(compilation){ //name通常写为名 'MyPlugin'
            //事件处理函数
        })
    }
}
```

**事件名称**

即要监听的事件名，即钩子名，所有的钩子：https://www.webpackjs.com/api/compiler-hooks

**事件类型**

这一部分使用的是 Tapable API，这个小型的库是一个专门用于钩子函数监听的库。

它提供了一些事件类型：

- tap：注册一个同步的钩子函数，函数运行完毕则表示事件处理结束
- tapAsync：注册一个基于回调的异步的钩子函数，函数通过调用一个回调表示事件处理结束
- tapPromise：注册一个基于Promise的异步的钩子函数，函数通过返回的Promise进入已决状态表示事件处理结束

**处理函数**

处理函数有一个事件参数```compilation```

## 应用

> 目的：生成文件列表，格式如下
>
> ```markdown
> 【main.js】
> 大小：4.076KB
> 
> 【main.js.map】
> 大小：3.7KB
> ```

**./src/a.js**

```js
// nothing
```

**./src/index.js**

```js
require('./a')
```

**webpack.config.js**

```js
var FileListPlugin = require("./plugins/FileListPlugin")

module.exports = {
    mode: "development",
    devtool: "source-map",
    plugins: [
        new FileListPlugin("文件列表.md")
    ]
}
```

**==./plugin/FileListPlugin==**

```js
module.exports = class FileListPlugin {
  constructor(filename = 'filelist.txt') {
    this.filename = filename; // 灵活处理，让使用plugin的开发人员自行传递参数
  }

  apply(compiler) {
    compiler.hooks.emit.tap('FileListPlugin', (complation) => {
      var fileList = [];
      for (const key in complation.assets) {
        var content = `【${key}】
大小：${complation.assets[key].size() / 1000}KB`;
        fileList.push(content);
      }

      var str = fileList.join('\n\n');
      complation.assets[this.filename] = { //向complation.assets对象中注入一个新的属性，供后续生成文件
        source() {
          return str;
        },
        size() {
          return str.length;
        },
      };
    });
  }
};
```



## 思考

> 为什么更改了 webpack 配置文件后，需要在命令行重启项目才能生效？
>
> webpack 监听文件变化重新打包时，略过了初始化阶段，直接从编译阶段开始，而webpack的最终配置是初始化阶段决定的，初始化阶段被略过了，自然修改的webpack配置不会生效。