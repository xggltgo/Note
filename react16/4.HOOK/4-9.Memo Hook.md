# Memo Hook

用于保持一些比较稳定的数据，通常用于性能优化

**如果React元素本身的引用没有发生变化，一定不会重新渲染**

## useMemo使用

`const variable = useMemo(() => first, [second])`

参数1 () => first：传递一个函数，该函数的返回结果作为`useMemo`的返回结果，保存到变量`variable `中

参数2[second]：数组，记录依赖项

**注意**

> `useMemo`和`useCallback`的对比
>
> 1. useCallback用于固定函数的引用地址，useMemo可以实现useCallback一样的效果
>
>    - useCallback实现
>
>      ```js
>      const handleClick = useCallback(() => {
>          setTxt(txt + 1);
>      }, [txt]);
>      ```
>
>    - useMemo实现
>
>      ```js
>      const handleClick = useMemo(() => {
>          return () => {
>            setTxt(txt + 1);
>          };
>        }, [txt]);
>      ```
>
> 2. useMemo适用范围更广，可以用来保持一些稳定的数据（例如：保持一个用于渲染的、内部有大量元素的、稳定的数组）

## Memo Hook 细节

1. 利用**useMemo**保持数组数据稳定，只要依赖项不改变，数组本身就不发生变化，数组中的元素也不会发生变化，都使用的同一个引用。那么，**如果React元素本身的引用没有发生变化，一定不会重新渲染**。
2. 也就是说，在渲染时Text组件不会再被重新创建，而是直接使用数组中保存的Text组件的引用。这样甚至连对比节点的时间都省略掉了，大大的提高了渲染效率。

```js
import React, { useMemo, useState } from 'react';
import Text from './Text';

export default function App() {
  const [range] = useState({ min: 1, max: 7000 });
  const [n, setN] = useState(0);

  const list = useMemo(() => {
    const list = [];
    for (let i = range.min; i <= range.max; i++) {
      list.push(<Text key={i} text={i} />);
    }
    return list;
  }, [range.min, range.max]);

  return (
    <div>
      {list}
      <input
        type="number"
        value={n}
        onChange={(e) => {
          setN(parseInt(e.target.value));
        }}
      />
    </div>
  );
}
```

