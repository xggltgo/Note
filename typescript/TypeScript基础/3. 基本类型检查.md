# 基本类型检查



## 类型约束和编译结果对比

### 如何进行类型约束 

仅需要在 变量、函数参数、函数返回值位置加上 `:类型`

```typescript
let name: string; //约定name为string类型
name = '123456';

function sum(a: number, b: number): number { //分别约定参数a,参数b,函数的返回值为number类型 （由于对该函数进行了类型检查，因此我们可以点击该函数并按下F2，来同时修改所有使用到了该函数位置处的函数名）
  return a + b;
}
let num: number = sum(1, 2); //由于对该函数进行了类型检查，因此我们可以点击该函数并按下F12，即可转到定义该函数的位置
```

**注意：**

1. ts在很多场景中可以自动完成类型推导，而不再需要开发者手动的进行类型约束
2. 技巧：若ts无法自动完成类型推导，则对应的变量、函数参数等位置处会出现三个小点，以示警告
   1. 变量、函数参数等位置处若出现三个小点，会被ts视为any类型
   2. any类型：表示任意类型，对该类型，ts不进行类型检查 

### 源代码和编译结果的差异

编译结果中不包含类型约束信息



## 基本类型

1. number：数字

2. string：字符串

3. boolean：布尔

4. 数组

   ```typescript
   // 约束数组的两种方式（约束数组时必须指定数组每一项的类型）
   let nums1: number[] = [1, 2, 3]; //语法糖 （表示数组的每一项为数字）
   let nums2: Array<number> = [1, 2, 3];
   ```

5. object：对象

   ```typescript
   let user: object; //约束user为对象类型
   user = {
     //...
   }
   ```

6. null和undefined

   1. 默认情况下，null和undefined是所有其他类型的子类型，它们可以被赋值给其他类型

      ```typescript
      // 默认情况下，以下代码并不会报错
      let n: number = undefined;
      let str: string = null;
      ```

   2. 为了避免默认情况下，null和undefined带来的隐患，我们需要在ts配置文件中添加编译选项配置`“strictNullChecks”:true`，以获得更加严格的空类型检查，配置后null和undefined不再能够赋值给其他类型，只能赋值给自身

   **tsconfig.json**

   ```json
   {
     "compilerOptions": {
       //编译选项
       "target": "ES2016", //配置编译结果所使用的代码的版本标准
       "module": "CommonJS", //配置编译结果所使用的模块化标准
       "lib": ["ES2016"], //配置ts可使用的全局环境 默认会有 "DOM" (浏览器环境) 此处没有node环境可供配置
       "outDir": "./dist", //配置编译结果的输出目录
       "strictNullChecks": true, //以获得更加严格的空类型检查，null和undefined不再能够赋值给其他类型，只能赋值给自身
     },
     "include": ["./src"], //配置需要编译的文件夹
     // "files": ["./src/index.ts"] //若不是需要编译整个文件夹，而是文件夹中特定的文件，则使用此配置（此配置会编译所配置的文件及其依赖的文件，类似于入口模块）
   }
   ```

   

## 其他类型

1. 联合类型：多种类型任选其一

   1. 配合类型保护进行判断
   2. 类型保护：当对某个变量进行类型判断之后，在判断的语句块中便可以确定它的确切类型，typeof可以触发类型保护

   ```typescript
   let s: string | null; //s既可以是string类型，又可以是null
   
   //类型保护伪代码：
   s //由于此处s的类型并没有确定，因此ts无法提供对应的智能代码提示
   if(typeof s === 'string'){
   	//类型保护（进了此判断，则表示s为string类型，则ts会提供string类型的智能代码提示）
   }
   ```

2. void类型：通常用于约束函数的返回值，表示该函数没有任何返回

   ```typescript
   function print(): void {
     console.log(123);
   }
   //注意：void类型，ts能够自动进行类型推导
   ```

3. never类型：通常用于约束函数的返回值，表示该函数永远不可能结束

   ```typescript
   function throwError(err: string): never {
     throw new Error(err); 
   }
   
   function always(): never {
     while (true) {
       //...
     }
   }
   ```

4. 字面量类型：使用一个字面量的值进行约束

   ```typescript
   let sex: 'male' | 'female'; //约束sex的值只能为'male'或'female'
   let arr: []; //约束arr只能为空数组 
   let user: { //约束user只能为一个对象，且该对象必须包含name属性（属性值为string类型）和age属性（属性值为number类型）
     name: string;
     age: number;
   };
   ```

5. 元组类型（Tuple）：一个固定长度的数组，并且数组中每一项的类型确定

   ```typescript
   let tu: [string, number, number]; //约束数组的长度必须为3，且数组的第一个元素只能是string类型，第二、第三个元素只能是number类型
   ```

6. any类型：any类型可以绕过类型检查，因此，any类型的数据可以赋值给任意类型

   ```typescript
   // 以下代码（将字符串成功赋值给一个number类型的变量）会造成隐患，因此不推荐随意使用any类型 
   let data: any = 'abc';
   let n: number = data; 
   ```

   

## 类型别名

 对已知的一些类型定义名称(减少重复代码，便与维护)	`type 类型名 = ...` 

```typescript
type Sex = 'male' | 'female';
type User = {
  name: string;
  age: number;
  sex: Sex; //此处使用类型别名Sex，相当于在此处书写了字面量 'male' | 'female'
};

let u: User;
function getUsers(sex: Sex): User[] { //使用类型别名User，约束数组中的每一项必须满足User的类型检查
  return [];
}
```



## 函数的相关约束

函数重载： 在函数实现之前，对函数调用的多种情况进行声明

```typescript
//通过函数重载，更加精细的控制函数的参数、返回值

/**
 * 得到a*b的结果
 * @param a 
 * @param b 
 */
function combine(a: number, b: number): number;
/**
 * 得到a和b拼接的结果
 * @param a 
 * @param b 
 */
function combine(a: string, b: string): string;
function combine(a: number | string, b: number | string): number | string {
  if (typeof a === 'number' && typeof b === 'number') {
    return a * b;
  } else if (typeof a === 'string' && typeof b === 'string') {
    return a + b;
  }
  throw new Error('a and b must be of the same type');
}
```

可选参数：可以在某些参数名后加上问号，表示该参数可以不用传递。可选参数必须在参数列表的末尾。

```typescript
//可选参数c（则c的类型可能是number类型或者undefined）
function sum(a: number, b: number, c?: number) {
  if (c) {
    return a + b + c;
  } else {
    return a + b;
  }
}

//默认参数c（配置默认参数，则表示该参数是可选的）
function add(a: number, b: number, c: number = 0) {
    return a + b + c;
}
```

